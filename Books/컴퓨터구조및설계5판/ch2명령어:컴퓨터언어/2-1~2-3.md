# 2.1 서론
- `컴퓨터 하드웨어에게 일을 시키려면` 하드웨어가 알아들을 수 있는 언어로 말을 해야하며, <br />
컴퓨터 언어에서 이를 `명령어(instruction)`라고 하고 그 어휘를 `명령어 집합(instruction set)`이라고한다. <br>

- 이 책에서 사용할 명령어 집합은 `RISC-V`이며, 다른 널리 쓰이는 명령어 집합으로 MIPS, Intext x86 등이 있다. <br />

- `하드웨어의 간결성`(제작이 쉬우면서 최소 비용에 최대 성능을 구현)은 1950년대나 지금이나 똑같이 중요한 고려사항이다.

- 이 장의 목표: `명령어`를 가르치면서 동시에 `명령어 집합의 하드웨어 표현 방식` 및 `상위 수준 언어와의 관계`를 보여 주는 것.
    - 예제는 c언어로 작성하며 2.15절에서 `자바 같은 객체지향언어`에서는 어떻게 달라지는지 설명
    
# 2.2 하드웨어 연산

- 모든 컴퓨터는 산술연산을 할 수 있어야 한다. <br />

- RISC-V 산술 명령어는 반드시 `한 종류의 연산`만 지시하며, `항상 변수 세 개`를 갖는 형식을 엄격히 지킨다. <br />
덧셈 같은 연산의 피연산자(operand)는 더해질 숫자 두개와 합을 기억할 장소 하나, 모두 세 개인 것이 자연스럽다. <br />

- 모든 명령어가 피연산자를 반드시 세 개씩 갖도록 제한하는 것은 하드웨어를 단순하게 하자는 원칙과 부합한다. <br />
이런 관점에서 하드웨어 설계의 3대 원칙 중 첫 번째를 도출할 수 있다. <br />
`설계 원칙1: 간단하기 위해서는 규칙적인 것이 좋다.`

- 다음은 RISC-V 어셈블리 언어는 두 변수 b와 c를 더해서 그 합을 a에 넣으라고 컴퓨터에 지시하는 것이다. <br>
add a, b c <br />
다음은 네 변수 b, c, d, e의 합을 a에 넣는 명령어들이다. <br />
add a, b, c
add a, a, d
add a, a ,e <br>

- f = (g + h) - (i +j); 와 같은 복잡한 문장에서 첫 RISC-V 명령어는 g와 h의 합을 구하여 결과치 `임시 저장`하기 위해 t0라는 임시 변수를 생성할 수 있다. <br>
add t0, g, h <br>
마찬가지로 i와 j의 합을 구하기 위해 임시 변수 t1을 생성하며, t0와 t1의 합을 구하여 결과를 도출한다.

- 고급 프로그래밍 언어와 달리 `한 줄에 명령어 하나`만 쓸 수 있으며, 줄이 끝나면 `주석`도 끝난다.

<img width="635" alt="그림2.1" src="https://user-images.githubusercontent.com/40673012/96049418-f4440c80-0eb2-11eb-869a-734bf8eb2901.png">

<img width="700" alt="그림2.1연장" src="https://user-images.githubusercontent.com/40673012/96049416-f27a4900-0eb2-11eb-8ecf-33f751fa9762.png">

# 2.3 피연산자
- 상위 수준 언어 프로그램과 달리 산술 명령어의 `피연산자`에는 `제약`이 있다. <br>
`레지스터`라고 하는 하드웨어로 직접 구현된 특수 위치 몇 곳에 있는 것만을 사용할 수 있다.

- `레지스터`는 하드웨어 설계의 기본 요소인 동시에 프로그래머에게도 보인다.  <br />
RISC-V 구조에서 레지스터의 크기는 64비트이고, 64비트가 한 던어리로 처리되는 일이 매우 빈번하여 `doubleword`라 부른다. <br /> 
32비트 그룹도 자주 사용되며 `word`라 부른다. <br /> 

- 프로그래밍 언어에서 사용하는 `변수`와 다르게 하드웨어 레지스터하나는 레지스터는 개수가 `한정` 된다. <br />
현대 컴퓨터는 RISC-V처럼 보통 32개의 레지스터가 있다.  <br />
때문에 기호 형태로 표현된 RISC-V 언어를 하향식으로 단계적 구체화할 때, `산술 명령어`의 모든 `피연산자`는 `32개의 64비트 레지스터 중 하나`이어야 한다는 `제약`이 추가된다.<br />

- 레지스터 개수를 32개로 제한하는 이유: `설계 원칙 2: 작인 것이 더 빠르다` <br />
레지스터가 아주 많아지면 `전기 신호`가 더 멀리까지 전달되어야 하므로 `클럭 사이클 시간`이 길어진다. <br />
하지만 `작은 것이 더 빠르다`가 절대적인 것은 아니다. ex) 레지스터를 31개로 해도 32개보다 빨라지지 않는다. <br />
컴퓨터 설계자는 `더 많은 레지스터를 원하는 프로그램`의 갈망과 클럭 사이클을 빠르게 하고 싶은 본인의 바람 사이에서 적절한 `타협점`을 찾아야 한다.

- 레지스터 개수를 32개로 제한하는 이유2: 명령어 형식에서 레지스터 지정에 사용되는 비트 수 때문에(2.5절)'


## 레지스터를 사용하여 c 치환문을 번역
- 프로그램 변수를 레지스터와 연관시키는 것은 컴파일러의 임무다. <br />
f = (g +h) - (i +f);    <br />
위의 c 프로그램에서 컴파일러가 변수 f, g, h, i, j를 레지스터 x19, x20, x21, x22, x23에 각각 할당했을때, <br />
컴파일된 RISC-V 코드를 보여라. <br />
```
add x5, x20, x21 // register x5 contains g + h
add x6, x22, x23 // register x6 contains i + f
sub x19, x5, x6 // f gets x5 - x6, which is (g + h) - (i +j)
```


## 메모리 피연산자
- 프로그래밍 언어에서 배열, 구조체 같은 `복잡한 자료구조` 하나에는 레지스터 개수보다 훨씬 많은 데이터 원소가 있을 수 있다. <br />
프로세서는 소량의 데이터만을 레지스터에 저장할 수 있지만, 컴퓨터 메모리는 수십억 개의 데이터를 저장할 수 있으므로, 복잡한 자료구조는 `메모리에 보관`한다.

<img width="478" alt="그림2.2" src="https://user-images.githubusercontent.com/40673012/96054956-cdd79e80-0ebd-11eb-9aff-1665a9cf0856.png">

- RISC-V의 산술연산은 레지스터에서만 실행되므로 메모리와 레지스터 간에 데이터를 주고받는 명령어가 있어야하고, <br>
이런 명령어를 `데이터 전송 명령어(data transfer instruction)`라 한다. <br>

- 메모리에 기억된 데이터에 접근하려면 명령어가 `메모리 주소`를 지정해야 한다. <br />
메모리는 주소가 인덱스 역할을 하는 큰 일차원 배열이며, 주소는 0부터 시작한다. <br />
예를 들어 그림 2.2에 세 번째 데이터 원소의 주소는 2이고, Memory [2]의 값은 10이다. <br />

- 메모리에서 레지스터로 데이터를 복사해 오는 데이터 전송 명령을 `적재(load)`라 한다. <br />
`적재 명령`은 `연산자 이름`과 메모리에서 읽어 온 `값을 저장할 레지스터`, 메모리 `접근`에 사용할 `상수`와 `레지스터`로 구성된다. <br />
`메모리 주소`는 `명령어의 상수` 부분과 `두 번째 레지스터값`의 합으로 구해진다.  <br />
RISC-V에서 이 명령어의 실제 이름은 1d(load doubleword)이다.<br />

---
### 메모리 피연산자를 사용하는 치환문의 번역
- A는 원소가 100개인 더블워드 배열이고 시작 주소(base address)가 x22에 기억되어 있으며, 변수 g, h는 레지스터 x20, x21에 할당 되었다고 가정한다.  <br>
g = h + A[8]; <br>
위의 c 프로그램을 컴파일하라. <br />
피연산자 중 하나가 메모리에 있으므로 A[8]을 레지스터로 옮긴다. <br>
이 배열 원소의 주소는 x22에 있는 배열의 시작 주소에 인덱스 8을 더한 값이다. <br>
이 데이터는 다음 명령어가 사용할 수 있도록 `임시 레지스터`에 넣는다. <br />

ld x9, 8(x22) // Temporary reg x9 gets A[8]. 이 명령러 그대로는 약간의 문제가 있어 뒤에서 수정된다. <br>

이제 필요한 값(A[8])을 레지스터 x9에 넣었으므로 덧셈을 구행한다.  <br />
add x20, x21, x9 // g = h + A[8] <br >
데이터 전송 명령어의 상수 부분(8)을 `변위(offset)`라 하고, 주소 계산을 위해 여기에 더해지는 레지스터(x22)를 <br />
`베이스 레지스터(base register)`라고 한다. 

---
<br />


- `컴파일러`는 `변수를 레지스터`와 연관 지을 뿐만 아니라 배열이나 구조체 같은 `자료구조를 메모리에 할당`한다. <br>
그 후 컴파일러는 자료구조의 시작 주소를 데이터 전송 명령에 넣을 수 있다. <br />

- 프로그램에서 8비트로 구성된 바이트를 많이 사용하므로 대부분의 컴퓨터는 `바이트 단위로 주소를 지정`한다. <br />
더블워드 주소는 더블워드를 구성하는 8바이트 주소 중 하나를 사용하므로, `연속된 더블워드의 주소는 8씩 차이`난다. <br />
그림 2.3은 실제 RISC-V 주소를 보여 준다. 예를 들어 세 번째 더블워드의 바이트 주소는 16이다. <br />

- 제일 왼쪽, 즉 `최상위(big end)` 바이트 주소를 더블워드로 사용하는 컴퓨터와 <br />
제일 오른쪽, 즉 `최하위(little end)` 바이트 주소를 더블워드 주소로 사용하는 컴퓨터 두 종료가 있다. <br />
RISC-V는 리틀엔디안 계열이다. <br />

- 바이트 주소의 사용은 `배열의 인덱스`에도 영향을 미치므로, <br />
앞의 코드에서 바이트 주소를 제대로 구하려면 배열 A의 베이스 레지스터 x22에 8 x 8 = 64 `변위값`을 더해야 한다. <br />
그래야 A[8/8]이 아닌 A[8]의 주소가 구해진다.  <br />

- 적재와 반대로 레지스터 내용을 메모리로 복사하는 명령을 `저장(store)`이라 한다. <br />
저장 명령의 생김새는 잭재와 같다. 즉 `연산자 이름`, `저장할 데이터를 갖고 있는 레지스터`, `베이스 레지스터`, 배열 원소 선택에 사용할 `변위`로 구성된다. <br />
RISC-V에서 이 명령어의 실제 이름은 `sd(store doubleword)`이다.

<img width="483" alt="그림2.3" src="https://user-images.githubusercontent.com/40673012/96054961-d16b2580-0ebd-11eb-9445-1b1aeed6b474.png">


- 고난도: 많은 구조에서 워드는 4의 배수 주소에서, 더블워드는 8의 배수 주소에서 시작해야 한다. <br />
이러한 요구사항을 `정렬제약(alignment restriction)`이라 한다. 정렬제약은 데이터 전송을 빠르게 한다(4장). <br />
RISC-V와 Intel x86에는 정렬 제약이 없지만, MIPS에는 정렬제약이 있다. <br />

---
### 적재와 저장을 사용한 번역
- 변수 h가 레지스터 x21에 할당되어 있으며, 배열 A의 시작 주소는 x22에 들어 있다고 가정하자. <br />
다음 C 문장을 RISC-V 어셈블리 프로그램으로 바꾸어라
<br />
A[12] = h +A[8];
<br />

- 처음 두 명령어는 앞의 예제와 같으나, A[8]을 선택하기 위해 적재 명령어가 바이트 주소에 맞는 `적절한 변위`를 사용한 것과<br />
add 명령어가 합을 x9에 넣는 것이 다르다. <br /><br />

ld x9, 64(x22) // Temporary reg x9 gets A[8]<br />
add x9, x21, x9 // Temporary reg x9 gets h + A[8]<br /><br />

- 마지막 명령어는 96(8x12)을 변위로, x22를 베이스 레지스터로 사용하여 합을 A[12]에 저장한다.
sd x9, 96(x22) // Stores h + A[8] back into A[12] <br />

- RISC-V에서 `메모리`와 `레지스터` 사이에 `더블워드`를 복사하는 명령어들이 `load doubleword`와 `store doubleword`인데,<br />
다른 컴퓨터에서는 데이터 전송을 위해 적재 명령어와 저장 명령어 외에 `다른 명령어`들을 함께 사용하기도 한다. (Intel x87이 이러한 구조로 2.17절에서 설명) 

---
 <br />
 
 ### 레지스터와 메모리
 - `컴퓨터의 레지스터`보다 `프로그램에서 사용하는 변수`가 더 많은 경우가 자주 있다.<br />
때문에  `컴파일러`는 `자주 사용되는 변수`를 최대한 레지스터에 넣고 `나머지 변수`는 메모리에 저장 후, 필요할때 레지스터에 넣는다.<br />
 자주 또는 한참 후 사용할 변수를 메모리에 넣는 것을 레지스터를 `스필링(spilling)`한다고 말한다. <br />
 
 -  레지스터에 저장된 데이터는 메모리 데이터보다 `사용하기 편리`하고, `접근시간이 짧고`, `처리량도 크며`,  `에너지도 적게` 든다.
    - 1. RISC-V의 산술연산 명령을 레지스터 두 개를 읽어서 연산한 다음 결과를 레지스터에 쓰지만, 
    데이터 전송 명령은 피연산자 하나를 읽거나 쓰는 일만 할 수 있다. (편리)
    - 2. 64비트 데이터라면 레지스터가 약 200배 빠르다 (2015년 기준)(빠르다)
    - 3. 에너지 측면에서 만 배 정도 더 효율적인다. (2015년 기준) (에너지 효율) <br />
    
- 좋은 성능을 얻고 에너지를 절약하기 위해서 1. 명령어 집합 구조가 충분한 레지스터를 제공하고, <br />
2. 컴파일러가 레지스터를 효율적으로 사용해야 한다.


## 상수 또는 수치 피연산자
- 프로그램의 연산에서 상수를 사용하는 경우가 많다.
    - 예: 배열의 다음 원소를 가리키도록 인덱스틑 증가시키는 경우
    
- `적재 명령`을 사용하여 메모리에서 상수를 읽어와 사용할 수 있다(상수는 프로그램이 적재될 때 메모리에 넣어진다). 예를 들어 레지스터 x22에 상수 4를 더하는 코드는 아래와 같다. <br /><br />

ld x9, AddrConstant4(x3) // x9 = constant. x3+ AddrConstant4는 상수 4가 저장되어 있는 메모리 주소라고 가정 <br />
add x22, x22, x9              // x22 = x22 + x9 (where x9 == 4) <br />

### 수치 피연산자
- 상수를 사용할 때 위의 예 처럼 적재 명령을 사용하지 않는 방법도 있다. <br />
피연산자 중 하나가 `상수인 산술연산 명령어`를 제공하는 것이다.<br />
수치 피연산자를 갖는 덧셈 명령어는 `addi(add immediate)`라 한다.
    - 예: 레지스터 x22에 4를 더하면 다음과 같다. addi x22, x22, 4      //x22 = x22 + 4  <br />
    
#### 장점
1. 상수 필드를 갖는 산술 명령어를 사용하면 매번 메모리에서 상수를 가져오는 것보다 
    연산이 훨씬 빠르고, 에너지를 덜 소모한다. <br />
2. 상수 0은 여러 유용한 변형을 제공하여 명령어 집합을 단순하게 한다.
    - 예: 첫 번째 피연산자로 0을 갖는 sub 명령어를 사용하면 레지스터값의 부호를 바꿀 수 있다. <br />
    따라서 RISC-V에서는 레지스터 x0의 값이 0으로 고정되도록 회로를 구현했다.

#### 사용빈도    
- SPEC CPU2006 벤치마크를 실행하면 RISC_V 살술 명령의 절반 이상이 상수를 피연산자로 사용한다.
- 상수 피연산자는 자주 사용되므로 addi는 대부분의 RISC-V 프로그램에서 가장 인기 있는 명령어다.

