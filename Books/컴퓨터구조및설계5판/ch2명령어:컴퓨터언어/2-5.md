# 2.5 명령어의 컴퓨터 내부 표현
- `명령어`도 컴퓨터 내부에서는 `높고 낮은 전기 신호의 연속`으로 저장되므로 숫자로 표현할 수 있다.
- RISC-V의 32개 레지스터들도 0부터 31 사이의 숫자로 표시된다. <br />

- 다음은 어셈블리 명령어의 실제 RISC-V 언어 버전을 십진수와 이진수 형태로 표현한 것이다. <br />
add x9, x20, x21  <br />
십집수 표현은 다음과 같다.

|0|21|20|0|9|51|
|--|--|--|--|--|--|

- 명령어의 각 부분을 `필드(field)`라 부른다. <br />
`첫 번째, 네 번째, 여섯 번째` 필드(0,0,51)는 RISC-V 컴퓨터에게 이 명령어는 `덧셈을 수행`한다고 알려주는 부분이다. <br />
`두 번째 필드`는 덧셈에 사용할 `두 번째 피연산자 레지스터의 번호`(21 = x21), <br />
`세 번째 필드`는 `다른 피연산자 레지스터 번호`(20 = x20)를 타나낸다. <br />
`다섯 번째 필드`는 계산 결과가 들어갈 `레지스터의 번호`(9 = x9)이다.

- 이 명령어의 각 `필드값`을 `이진수로 표시`하면 다음과 같다. <br />

|0000000|10101|10100|000|01001|0110011|
|--|--|--|--|--|--|
|7bits|5bits|5bits|3bits|5bits|7bits|

- 위 예제의 레이아웃을 `명령어 형식`(instruction format)이라고 한다.
- RISC-V 명령어의 길이는 워드 길이인 32비트이다.
    - "간단하기 위해서는 규칙적인 것이 좋다"는 설계 원칙에 따라 예외 없이 32비트다.
- `명령어를 숫자로 표현`한 것을 `기계어`라 하고, 이런 `명령어들의 시퀸스`를  `기계 코드`라 한다.

## 16진수
- 거의 모든 컴퓨터의 데이터 길이는 4의 배수이므로 16진수(hexadecimal)가 많이 사용된다. <br />
- 아래 그림은 16진수와 이진수 간의 변환을 보여주며, 십진수 뒤에는 ten, 이진수 뒤에는 two, 16진수 뒤에는 hex라는 아래 첨자를 붙인다(첨자가 없는 경우 십진수로 생각).
- C와 자바에서는 16진수는 0xnnnn으로 표시한다.

<img width="570" alt="16진수-2진수 변환표" src="https://user-images.githubusercontent.com/40673012/96657084-391ce700-137c-11eb-972d-eb771fac5e09.png">

<img width="570" alt="16진수-2진수 변환" src="https://user-images.githubusercontent.com/40673012/96657344-e98aeb00-137c-11eb-941f-356e67aa927b.png">

## RISC-V 명령어의 필드
- 다음은 RISC-V 명령어의 각 `필드`이다. <br />

|funct7|rs2|rs1|funct3|rd|opcode|
|--|--|--|--|--|--|
|7bits|5bits|5bits|3bits|5bits|7bits|

- opcode: 명령어가 실행할 연산의 종류로서 연산자(opcode)라고 부른다.
- rd: 목적지(destination) 레지스터. 연산 결과가 기억된다.
- funct3: 추가 opcode 필드.
- rs1: 첫 번째 근원지(source) 피연산자 레지스터.
- rs2: 두 번째 근원지 피연산자 레지스터.
- funct7: 추가 opcode 필드

### 문제점
- 위의 필드보다 길이가 더 길어야 하는 경우 문제가 생길 수 있다.
    - 예: load doubleword 명령어는 레지스터 필드 두개와 상수 필드 하나가 필요하다. 만일 위의 5비트 필드 중 하나를 주소로 쓴다면 2⁵=32 보다 작은 값만을 사용할 수 있다.
- 이런 문제 때문에 모든 명령어의 길이를 같게 하고 싶은 생각와 명령어 형식을 한 가지로 통일하고 싶은 생각 사이에서 충돌이 생길다.
    
### 해결
- 설계원칙 3: 좋은 설계에는 적당한 절충이 필요하다.
- RISC-V 설계자들은 모든 명령어의 길이를 갖게 하되. 명령어 종류에 따라 형식은 다르게 했다.(정청)
#### R-타입
- 위의 명령어 형식은 `R(register)-타입` 또는 R-형식이라 한다.<br />
#### I-타입
두 번째 명령어 형식은 `I-타입`으로 `상수 피연산자 하나`를 갖는 산술 피연산자에 의해 사용되며(addi 명령어 포함)<br />
`적재 명령어`에서도 사용된다.<br />

|immediate|rs1|funct3|rd|opcode|
|--|--|--|--|--|
|12bits|5bits|3bits|5bits|7bits|

- 12비트 수치값은 2의 보수값으로 해석되므로 -2¹¹에서 2¹¹ -1 까지의 정수를 표현할 수 있다. <br />
- `I-타입` 형식이 `적재 명령어`에 사용될 경우 `수치값`은 바이트 변위를 나타내어
`load doubleword 명령어`는 베이스 레지스터 rd에 있는 베이스 주소에서
+-2¹¹ = +-2048바이트(+-256더블워드) 안에 있는 더블워드를 지정할 수 있다.

#### S-타입
- 2.3 절의 적재(load doubleword) 명령을 보자 <br />
ld x9, 64(x22) // Temporary reg x9 gets A[B]
- rs1 필드에는 22(x22의 번호), 수치 필드에는 64, rd 필드에는 9(x9의 번호)가 들어간다.
- `두 개의 근원지 레지스터`(베이스 주소, 저장할 데이터를 위한 주소)와 `주소 변위를 위한 수치 필드`가 필요한 <br />
`저장 명령어 sd`(store doubleword)를 위해서는 또 다른 명령어 형식이 필요한데 이 명령어 형식은 S - 타입이다. <br />

|immediate[11:5]|rs2|rs1|funct3|immediate[4:0]|opcode|
|--|--|--|--|--|--|
|7bits|5bits|5bits|3bits|5bits|7bits|

- S - 타입 형식에서 12비트 수치값은 하위 5비트와 상위 7비트 두 개의 필드로 나뉜다. <br />
모든 명령어 형식에서 rs1과 rs2 필드의 위치를 같게 유지하기 위함이다. <br />
명령어 형식을 가능한 비슷하게 유지하느 것이 하드웨어 복잡도를 낮추어 준다(opcde, funct3 필드도 상동).

<img width="479" alt="그림2.5" src="https://user-images.githubusercontent.com/40673012/96792801-17803600-1436-11eb-9dec-7470060473f8.png">


- 명령어 형식은 `첫 번째 필드 값`을 보면 `구분`할 수 있다. <br />
형식별로 첫 번째 필드인 opcode가 가질 수 있는 값이 다르다.<br />
그림 2.5는 RISC-V 명령어의 각 필드 내용을 보여준다.

### RiSC-V 어셈블리 언어를 기계어로 번역
- x10애 배열 A의 시작 주소가 기억되어 있고, x21은 변수 h에 대응된다. 
- A[30] = h + A[30] + 1; <br /> <br />

컴파일 후<br /> <br />

ld x9, 240[x10]     // Temporary reg x9 gets A[30] <br />
add x9, x21, x9    // Temporary reg x9 gets h+A[30} /<br />
addi x9, x9, 1       //  Temporary reg x9 gets h+A[30 +1 <br />
sd x9, 240[x10]     // Temporary h+A[30]+1 back into A[30] <br /> <br />

기계어로 변환<br /> <br />

(독자가 알아보기 위한 십진수 변환 작업)
|immediate|rs1|funct3|rd|opcode|
|--|--|--|--|--|
|240|10|3|9|3|

|funct7|rs2|rs1|funct3|rd|opcode|
|--|--|--|--|--|--|
|0|9|21|0|9|51|

|immediate|rs1|funct3|rd|opcode|
|--|--|--|--|--|
|1|9|0|9|19|

|immediate[11:5]|rs2|rs1|funct3|immediate[4:0]|opcode|
|--|--|--|--|--|--|
|7|9|10|3|16|35|


(최종)<br /> <br />
|immediate|rs1|funct3|rd|opcode|
|--|--|--|--|--|
|000011110000|01010|011|01001|0000011|

|funct7|rs2|rs1|funct3|rd|opcode|
|--|--|--|--|--|--|
|0000000|01001|10101|000|01001|011011|

|immediate|rs1|funct3|rd|opcode|
|--|--|--|--|--|
|000000000001|01001|000|01001|0010011|

|immediate[11:5]|rs2|rs1|funct3|immediate[4:0]|opcode|
|--|--|--|--|--|--|
|0000111|01001|01010|011|10000|0100011|

- 주소 변위 240은 두 수치 필드에 걸쳐있다. 수치값의 상위 부분은 비트 5부터 그 위쪽 비트들을 저장하고 <br />
하위 부분은 나머지 5비트를 저장하기 때문에, 변위 240을 2⁵으로 나누면 분리할 수 있다. <br />
수치 필드의 상위 부분에는 몫 7, 하위 부분에는 나머지 16이 들어간다.

### 고난도
- RISC-V는 add와 sub 명령어를 따로 가지고 있지만, addi에 대응하는 `subi`를 갖고 있지 않다. <br />
2의 보수법을 사용하기 때문에 addi가 상수 뺄셈에도 사용될 수 있기 때문이다.

### 하드웨어/소프트웨어 인터페이스
- 그림 2.6은 이 절에서 설명한 RISC-V 기계어의 요약이다.

<img width="568" alt="그림2.6" src="https://user-images.githubusercontent.com/40673012/96798585-2bc73180-143c-11eb-9a89-9b248c0338c3.png">

- 오늘날의 컴퓨터는 두 가지 중요한 원리에 바탕은 둔다. <br />
1. 명령어는 숫자로 표현된다.  <br />
2. 프로그램은 메모리에 기억되어 데이터처럼 읽고 쓸 수 있다. <br /><br />

- 이것이 `내장 프로그램`의 개념이다. <br />
그림 2.7은 내장 프로그램의 장점을 보여 준다. <br />
메모리에는 편집기가 편집 중인 소스 코드, 컴파일된 기계어 프로그램, 실행 프로그램이 사용하는 텍스트 데이터, <br />
기계어를 생성하는 컴파일러까지도 기억될 수 있다. <br />

- 명령어를 `숫자`처럼 취급하게 된 결과, `프로그램`이 `이진수 파일 형태로 판매` 되었다. <br />
만약 기존 명령어 집합과 호환성이 있다면 다른 컴퓨터의 소프트웨어를 물려받을 수 있다는 의미다. <br />
이러한 `이진 호환성`(binary compatibility) 문제 떄문에 상업적으로 살아남는 명령어 집합 구조는 극히 소수다.



<img width="441" alt="그림2.7" src="https://user-images.githubusercontent.com/40673012/96798606-3aade400-143c-11eb-9906-19d20b3ff8e0.png">

