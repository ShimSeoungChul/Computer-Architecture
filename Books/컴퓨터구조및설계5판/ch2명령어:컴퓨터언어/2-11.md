# 2.11 병렬성과 명령어: 동기화
- 태스크가 서로 독립적일 경우 병렬처리가 쉽다. <br />
하지만 서로 `협력`하는 경우도 많다.
- 협력: 어떤 태스크들이 읽어야 하는 새로운 값을 다른 태스크들이 쓰는 것 <br />

- 읽는 태스크가 `안전`하게 읽을 수 있도록 쓰는 태스크가 언제까지 쓰기를 마쳐야 하는지 알려면 <br />
태스크들이 `동기화`되어야 한다.
- 이들이 동기화되지 않으면 `데이터 경쟁관계`(data race)의 위험이 있다. <br />
- 데이터 경쟁관계: 이벤트가 일어나는 `순서`에 따라 프로그램의 `결과가 달라`질 수 있는 상황이다. <br />
`발생 원인`: `다른 스레드`에서 나온 두 `메모리 접근`이 같은 위치를 향하고, 그 중 적어도 하나가 `쓰기`이며 이들이 잇따라 일어날 때 발생한다.

## lock과 unlock
- 컴퓨팅에 있어서도 `동기화 메커니즘`은 일반적으로 사용자 수준 소프트웨어 루틴에서 제공된다. <br />
이 소프트웨어 루틴은 `하드웨어가 제공하는 동기화 명령`을 사용한다. <br />
`lock`과 `unlock`을 그대로 이용하여 `단 하나의 프로세서만 작업할 수 있는 영역`을 생성할 수  있으며(상호배재[muial exclusion]), <br />
더 복잡한 동기화 메커니즘을 구현하는 데도 사용할 수 있다.  <br />

- `멀티프로세서에서 동기화`를 구현하기 위해서는 `메모리 주소`에서 `읽고` `수정`하는 것을 <br />
`원자적`으로 처리할 능력을 가진 `하드웨어 프리미티브`가 있어야 한다. <br />
    - 즉 메모리에서 읽고 쓰는 중간에 `아무것도 끼어들 수 없어야` 한다. <br />
    그러한 능력이 없으면 기본 동기화 프리미티브 구현 비용이 매우 비쌀 것이고, <br />
    비용은 프로세서 수가 증가와 비례할 것이다. <br />

- `기본 하드웨어 프리미티브를 대신`하는 많은 방법도 있다. <br />
모두 `메모리 주소`에서 `읽고` `수정`하는 것을 `원자적`으로 처리하는 방법을 제공하고, <br />
읽고 쓰는 것이 원자적으로 처리되었는지 알려 주는 방법도 함께 제공한다. <br />

- 일반적으로 설계자는 기본 하드웨어 프리미티브를 사용자가 쓸 것이라고 생각하지 않는다. <br />
시스템 프로그래머가 동기화 라이브러리를 구축하는 데 사용할 것이라 생각한다. <br />


## 방법1 - 원자적 교환
- `동기화 연산` 구축을 위한 전형적인 연산은 `원자적 교환`(atomic exchange 또는 atomic swap)인데,<br />
이 연산은 레지스터의 값을 메모리 값과 교환한다.
- 이것을 `기본 동기화 프리미티브 구축`에 어떻게 사용하는지 보기 위해 간단한 lock을 만들어 보자. <br />

- 이 lock은 `0`이면 사용 가능, `1`이면 사용 불가를 표시한다고 가정한다. <br />
프로세서는 `레지스터`에 있는 값 1과 `메모리`에 있는 lock을 맞바꿈으로써 lock을 1로 만들려 한다.  <br />
만약 `다른 프로세서가 이미 접근을 주장`하였다면 교환 명령어가 가져온 값은 1일 것이며, 그렇지 않은 경우 0일 것이다. <br />
후자의 경우(결과값이 0) 그 값이 1로 바뀌어 다른 프로세서에 있는 경쟁관계의 교환 명령이 0을 읽어 가지 못하게 한다. <br />

- 예를 들어 동시에 교환을 하려고 하는 두 프로세서를 가정하자. <br />
이 경쟁은 금방 끝나게 되는데 `한 프로세서만`이 교환을 먼저 수행해서 0을 가져온다. <br />
`두 번째 프로세서`는 1을 읽어 올 것이다. <br />
동기화를 구현하기 위해 교환 프리미티브를 사용할 때의 `핵심`은 연산이 원자적이라는 것이다. <br />
즉 `교환`은 `나뉠 수 없는`(indivisible)것이라서 두 개의 동시 교환은 `하드웨어`에 의해 순서가 결정된다. <br />
두 프로세서가 이런 방법으로 `동기화 변수`를 설정하여 두 프로세서 모두 그들이 변수를 설정했다고 생각하는 경우는 나올 수 없다. <br />

- `단일 원자적 메모리 연산`을 구현하려면 `프로세서 설계` 시 몇 가지 문제를 극복해야한다. <br />
이 연산은 메모리 읽기와 쓰기를 `인터럽트`가 `불가능`한 단일 명령어에서 처리해야 하기 때문이다. 

## 방법2 - 명령어 두 개 사용
- 명령어 두 개를 사용하는 방법에서 `두 번째 명령어`는 두 명령어가 `원자적`으로 실행되었는지 여부를 표시한다.
    - 다른 프로세서에서 실행된 모든 연산이 이 두 명령어보다 `먼저 시작`되어 `먼저 끝나`든지, <br />
    `나중에 시작`되어 `나중에 끝난` 것처럼 보인다면 이 한 쌍의 명령어는 실질적으로 원자적이다.
    - 두 명령어가 `실질적으로 원자적`이라면 다른 어느 프로세서도 이 `두 명령어 사이에서 값을 바꿀 수 없다`. <br />
    
- RISC-V에는 이러한 `명령어 쌍`으로 `lr.d`(load-reserved doubleword, 특수한 적재)와 `sc.d`(store-conditional doubleword, 특수한 저장)가 있다.
- 이 명령어 쌍은 `순차적`으로 사용된다. 
    - 만약 `lr.d 명령어`가 사용하는 `메모리 주소`의 내용이 같은 주소에 대한 `sc.d 명령어`가 실행되기 전에 바뀐다면 sc.d 명령은 실패하게 되어 메모리에 값을 쓰지 못하게 된다. 
    - sc.d는 레지스터값을 메모리에 저장하고 동시에 `성공하면` 또 다른 레지스터를 0으로, `실패하면` 1로 만든다. <br />
    따라서 sc.d는 레지스터를 세 개 사용한다.  <br />
    1. 메모리 주소를 갖는 레지스터, <br />
    2. 원자적 연산의 성공 여부를 나타내는 레지스터, <br />
    3. 성공 시 메모리에 저장할 값을 갖고 있는 레지스터.
- lr.d 명령어는 메모리에서 값을 읽어 오고, sc.d는 `성공했을 때만` 0을 가져오기 때문에, <br />
다음 명령어 시퀸스는 x20이 가리키는 메모리 내용에 대한 원자적 교환을 구현한다. <br />
    again: lr.d x10, (x20) // load-reserved <br />
              sc.d x11, x23, (x20)  // store-conditional <br />
              bne x11, x0, again    // branch if store fails <br />
              addi x23, x10, 0        // put loaded value in x23 <br />
              addi x23, x10, 0       // put loaded value in x23 <br />
              
- lr.d 명령어와 sc.d 명령어 사이에 프로서서가 끼어들어서 메모리값을 바꾸면, <br />
sc.d는 x11에 1을 넣기 때문에 again부터 다시 실행해야 된다.
<br />

## 고난도
- 원자적 교환은 다중프로세서 동기화를 위해 제시된 것이지만 
`운영체제`가 `단일프로세서`에서 `다중프로세스`를 다루는 데도 유용하다. <br />
단일프로세서에서 아무것도 끼어들지 않았다는 것을 확실하게 하기 위해, <br />
두 명령어 사이에서 문맥 교환이 일어나도 sc.d는 실패하게 된다.<br />


