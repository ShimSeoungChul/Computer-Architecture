# 2.4 부호있는 수와 부호없는 수
- 컴퓨터 내에서는 일련의 높고 낮은 `전기 신호`의 형태로 숫자를 저장하므로 `기수 2`인 수로 볼 수 있다. <br />

- 모든 정보는 이진 자릿수(binary digit), 즉 비트로 구성되므로 비트가 계산의 기본 단위가 된다.

- 다음 그림은 RISC-V의 더블워드 내의 비트에 번호를 붙이는 방식과 숫자 1011(2)의 표현을 보여준다.

<img width="447" alt="2.4장더블워드" src="https://user-images.githubusercontent.com/40673012/96523766-841df800-12b1-11eb-9cee-06f7f206239c.png">

- `LSB(least significant bit)`는 가장 오른쪽의 비트 0, `MSB(most significant bit)`는 가장 왼쪽의 비트 63을 나타낸다.
- RISC-V 더블워드의 길이는 64 비트이므로 2⁶⁴가지의 서로 다른 64비트 패턴을 표현할 수 있다.
- 64 비트 이진수는 비트값과 2의 멱수를 곱한 값으로 표현할 수 있다.(여기서 xi는 x의 i번째 비트를 의미한다.) <br />
(x₆₃ x 2⁶³) + (x₆₂ x 2⁶²) + (x₆₁ x 2⁶¹) + ... + (x₁ x 2¹) + (x₀ x 2⁰)  <br />
이런 양수를 `부호없는 수`라 한다.
- 연산 결과가 하드웨어에 구현된 오른쪽 비트들만으로는 표현이 불가능하면, `오버플로`가 발생했다고 한다.
<br/> 오버플로의 `대처방안`은 프로그래밍 언어와 운영체제 및 프로그램의 못이다.

## 부호와 크기(sign and magnititude) 표현법

- 컴퓨터 프로그램은 양수와 음수를 모두 계산한다. 따라서 양수와 음수를 구별하는 표현방법이 필요하다. <br />
별도의 부호를 한 비트로 덧붙이는 방법을 부호와크기 표현법이라한다.  

### 부호와 크기 표현법의 단점
1. 오른쪽, 왼쪽 어디에 부호 비트를 붙여야 하지는 명확하지 않다.<br />
2. 부호와 크기 표현법의 `덧셈기`는 부호를 결정하기 위해 `한 단계가 더 필요`하다. 최종 부호가 무엇이 될지 미리 알 수 없기 때문이다.<br />
3. 부호 비트가 따로 붙기 떄문에 양의 0과 음의 0을 갖는다.<br />

- 이러한 단점 때문에 부호화 크기 표현법은 잘 쓰지 않으며, 오늘날의 모든 컴퓨터는 `부호있는 수`를 `2의 보수`로 표현한다.


## 2의 보수(two's complement) 표현
- 0들이 앞에 나오면 양수이고, 1들이 앞에 나오면 음수가 되는 표현 방식을 2의 보수 표현법이라고 한다.
    - 하드웨어를 간략하게 하는 표현방식이 채택된 것이다.<br />

출처:http://tcpschool.com/c/c_refer_negativeNumber
![2의 보수](https://user-images.githubusercontent.com/40673012/96650921-b0e41500-136e-11eb-94bc-2a2bc807a7ca.png)

<img width="674" alt="2의 보수" src="https://user-images.githubusercontent.com/40673012/96651211-497a9500-136f-11eb-9731-dbe841320728.png">

- 전체의 절반인 양수 0부터 9,223,372,036,854,775,807 (2⁶³-1) 까지는 `양수`이고, <br />
그 다음 `비트 패턴(10000...0000two)`은 가장 큰 `음수` `-9,223,372,036,854,775,808 (-2⁶³) 나타내며,<br />
계속 작은 음수가 이어져서 -9,223,372,036,854,775,807 (-2⁶³)  부터 -1 (1111...1111 two)까지 감소한다. <br />

### 장점
- 2의 보수 표현에서 모든 음수는 MSB가 1이다. 따라서 하드웨어가 양수, 음수를 구분할 때 MSB만 검사하면 된다.
    - MSB를 부호 비트(sign bit)라고 부른다.
- 부호 비트의 역할을 이해하면, 비트값에 2의 멱수를 공한 값으로 64 비트의 양수와 음수를 모두 표현할 수 있다.
    - (x₆₃₂₁₀ x -2^63) + (x₆₂ x 2^62) + (x₆₁ x 2^61) + ... + (x₁ x 2^1) + (x₀ x 2^0)  <br />
    - `부호 비트`에는 -2^63를 곱하고, `나머지 비트`들은 각각의 위치에 해당하는 양의 기수 값을 곱한다.


### 이진수를 십진수로 변환
- 64비트의 2의 보수로 표현된 다음 수의 십진수값은? <br />
111111111  111111111  111111111 111111111  111111111  111111111  111111111  111111100(two)

- (1 x -2^63) + (1x 2^62) + (1x 2^61) + ... + (0 x 2^1) + (0 x 2^0) 
=  -2^63 + 2^62 + 2^61 + ... + 2^2 + 0 + 0 <br />
= -9,223,372,036,854,775,808 + -9,223,372,036,854,775,804 <br />
= -4

### 주의사항
- 부호 비트가 틀렸을 때(음수인데 MSB가 0이 되거나 양수인데 1이 되는 경우) 오버플로가 발생한다.

### 2의 보수 연산에서 사용할 수 있는 두 가지 빠른 계산법
#### 빠른 부호 바꾸기
2(ten)의 부호를 바꾸고, -2(ten)의 부호를 다시 바꿔서 결과를 확인하라.

2(ten) = 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000010(two) <br/>
`0은 1로, 1은 0으로 바꾸고 1을 더하여 부호를 바꾼다.`
111111111  111111111  111111111 111111111  111111111  111111111  111111111  111111100(two) <br />
+ 1(two)<br/>
111111111  111111111  111111111 111111111  111111111  111111111  111111111  111111110(two)
<br />
= -2(two) <br />
반대로 하기 <br /><br />

111111111  111111111  111111111 111111111  111111111  111111111  111111111  111111110(two) 을 0은 1로 1은 0으로 바꾸로 1을 더한다.<br />
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001(two)<br />
+ 1(two)<br/>
= 
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000010(two)<br />
= 2(two) <br />

#### 빠른 부호확장
- 16비트 이진수 2(two)과 -2(two)을 64비트 이진수로 변환하라  <br />
- 2의 16비트 표현은 다음과 같다. <br />
00000000 00000010(two) = 2(ten) <br />
최상위 비트(0)을 취해서 더블 워드의 왼쪽 부분에 48번 복사하고, <br />
더블워드의 오른쪽 부분에 원래의 값을 그대로 복사해서 64비트 이진수로 만들 수 있다. <br />
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000010(two) = 2(ten) 


## 하드웨어/소프트웨어 인터페이스
- 부호있는 수와 부호없는 수는 산술연산뿐만 아니라 `적재 명령어`와도 상관있다.
- 레지스터 내부에 `정확한 값`을 적재하기 위해 `부호있는 적재`의 경우 레지스터의 남는 곳을 채우기 위해 `부호를 반복하여 복사`한다.
- `부호없는 적재`의 경우 단순히 데이터의 왼쪽을 0으로 채운다.
- RISC-V는 `바이트 적`재를 위해 `두 개의 명령어`를 제공한다.<br />
`lbu(load byte unsigned) 명령어`는 바이트를 부호없는 수로 간주하고 남은 56비트를 0으로 채운다.<br />
`lb(load byte) 명령어`는 바이트를 부호있는 정수로 간주하여 부호활장 한 후 레지스터를 채운다.<br />
    - C 프로그램의 바이트는 매우 짧은 부호있는 정수보다는 `문자`를 표시하지는 데 더 많이 사용되므로, <br />
    바이트 적재에 실제로 lbu 명령어만 사용된다. 
    


