# 2.7 판단을 위한 명령어

## 판단 명령어
- 컴퓨터는 판단 기능으로 입력 데이터나 연산 결과에 따라 다른 명령어를 실행할 수 있다.
- 프로그래밍 언어에서는 보통 if문장으로 판단 기능을 표현한다. 
- RISC-V 어셈블리 언어는 go to가 있는 if문과 비슷한 두 개의 판단 명령어를 갖고 있다.
- 이런 명령어들을 전통적으로 `조건부 분기`(conditional branch)라 부른다.
 
### beq
- beq rs1, rs2, L1 <br />
r1, r2 값이 같으면 L1에 해당하는 문장으로 가라는 뜻이다. <br />
`branch if equal`을 의미한다.

### bne
- bne rs1, rs2, L1 <br />
r1, r2 값이 같지 않으면 L1로 가라는 뜻이다. <br />
branch if not equal을 의미한다.

### if-then-else를 조건부 분기로 번역
- f, g, h ,i ,j 는 변수이고, 각각은 레지스터 x19부터 x23에 해당한다.  <br />
아래 C언어 if 문장을 컴파일한 RISC-V 코드는?<br /><br />

    if (i == j) f = g + h; else f = g - h;<br /><br />

- 그림 2.9는 RISC-V 코드가 해야 할 일을 보여 주는 순서도다. <br /><br />

1. i와 j가 같다면 분기를 원하지만, 실제로는 조건을 반대로 검사해 두 값이 다를 경우 분기하는 것이 더 효율적이다.
bne x22, x23, ELSE // go to Else if i != j <br /><br />

2. `치환문`은 연산 하나를 실행하는 것이므로 피연산자가 모두 레지스터에 있다면 `명령어 하나`로 번역된다. <br />
add x19, x20, x21 // f = g + h (skipped if i != j) <br /><br />

3. 위 명령을 실행 후 if 문장의 끝부분으로 간다.  <br />
이것은 `무조건 분기`(unconditional branch)라는 새로운 종류의 분기 명령으로 해결한다. <br />
이 명령어는 프로세서에게 항상 분기하라고 말한다. <br />
RISC-V에서는 무조건 분기를 표현 하는 한 가지 방법으로 `조건이 항상 참인 조건부 분기 명령어`를 사용한다.
beq x0, x0, Exit // if 0 = 0, go to Exit <br /><br />

4. else 부분의 치환문도 명령어 하나로 번역된다. <br />
단, 이 명령어에는 `Else라는 레이블`을 붙인다. <br />
그리고 이 명령어 뒤에는 if-then-else 문장의 끝을 표시하는 Exit라는 레이블을 둔다.
Else : sub x19, x20, x21 // f = g - h (skipped if i = j)
Exit:   <br />

<img width="445" alt="그림2.9" src="https://user-images.githubusercontent.com/40673012/96801453-98ddc580-1442-11eb-9a8f-02507f4bb652.png">
    
- 컴파일러나 어셈블리 언어 프로그래머가 해야 할 이 귀찮은 `분기 주소 계산`을 `어셈블러`가 대신해 준다. <br />
이는 적재와 저장 명령어를 위해 데이터 주소를 계산해 주는 것과 똑같다.<br />

- `컴파일러`가 소스 프로그램에는 없는 `분기 명령`이나 `레이블`을 만들어 내는 경우도 많다. <br />
필요한 레이블과 분기 명령을 일일이 표시하지 않아도 되는 것이 `상위 수준 프로그래밍 언어의 장점` 중 하나이며, <br />
상위 수준 언어를 사용하면 코딩이 더 빨라지는 이유이기도 한다.

## 순환문
- 판단 기능은 if 문장에서도 중요하지만 `순환문`에도 중요하다. 두 경우 같은 어셈블리 명령어가 사용된다.

### while 순환문의 번역
- while (save[i] == k) <br />
    i += 1; <br /><br />
 위의 코드는 C 순환문으로 i, k가 레지스터 x22와 x24에 할당되었고 배열 save의 시작 주소가 x25에 저장되어 있다고 할 때 이에 해당하는 RISC-V 어셈블리 코드를 보여라
 
 - 첫 번째로 save[i]를 임시 레지스터에 적재하기 위해 주소를 구한다. <br />
 `바이트 주소 문제` 때문에 i에 8을 곱해 save의 시작 주소에 더하여 주소를 만든다. <br />
 3비트씩 좌측 자리를 이동을 하면 8을 곱한 것과 같으므로 `slli 연산`을 사용한다. <br />
 순환의 끝에서 처음 명령어로 되돌아 갈 수 있도록 Loop 레이블을 추가한다. <br />
    Loop: slli x10, x22, 3 // Temp reg x10 = i * 8 <br />
`x10` 값에 `x25`에 있는 save의 베이스 주소값을 더하여 `save[i]의 주소`를 계산한다. <br />
    add x10, x10, x25 //    x10 = address of save[i] <br />
    
- 두 번째로 이 주소를 이용해서 save[i]를 임시 레지스터에 넣는다. <br />
    ld x9, 0(x10) // Temp reg x0 = save[i] <br />
    
- 세 번째로  반복 검사를  수행해서 save[i] != k 이면 빠져나간다. <br />
    bne x9, x24, Exit // go to Exit if save[i] != k <br />
    
- 네 번째로  i에 1을 더한다. <br />
    addi x22, x22, 1 // i = i +1 <br />

- 다섯 번째로 순환문의 끝에서는 맨 앞의 while 조건 검사로 되돌아가야 한다.  <br />
마지막으로 이 명령의 다음에 Exit 레이블을 넣으면 번역이 끝난다.  <br />
    beq x0, x0, Loop // go to Loop  <br />
    Exit:   <br />

### 대소 비교 (for문)
- 두 변수 간의 대소 비교가 필요할 때도 있다. <br />
    - 예: `for 순환문`에서 인덱스 변수 값이 0보다 작은지를 검사
- 필요한 비교를 모두 나열하면 les than(<), less than or equal(<=), greater than(>),greater than or equal(>=), equal(=), not equal(!=)
- 비교 명령은 부호있는 수와 부호없는 수를 모두 다룰 수 있어야 한다. <br />
    - 1. MSB가 1인 수가 음수인 경우 MSB가 0인 어떤 양수보다 작다
    - 2. 부호없는 수의 경우 MSB가 1인 수가 MSB인 어떤 수보다 더 크다
     - RISC-V는 이 두 경우를 처리하는 명령어들을 제공한다.
- `blt`(branch if less than): 이 명령어는 레지스터 rs1과 rs2의 값을 비교하여 rs1의 값이 작으면 분기를 택한다. <br />
이때 두 레지스터값들은 2의 보수로 취급된다.
- `bge`(branch if greater than or equal): blt 명령어와 반대의 경우 즉, rs1의 값이 최소한 rs2의 값이 되어야 분기를 택한다.
- `bltu`(branch if less than, unsigned): rs1의 값이 rs2의 값보다 작아야 분기를 택하는데 이때는 레지스터값들이 `부호없는 수`로 취급된다.
- `bgeu`(branch if grater than or eqaul, unsigned): bltu 명령어와 반대의 경우 분기를 택한다.

#### 대소 비교의 기타 방법들
- 1. 비교 결과에 따라 레지스터값을 정한 후 이 값을 `beq`나 `bne`로 검사해서 분기하는 방법
    - MIPS 명령어 집합에서 사용된 이 방법은 `프로세서 데이터패스를 약간 더 단순`하게 만드나 프로그램 실행을 위해 `더 많은 명령어`가 필요하다.
- 2. `명령어 실행 결과를 요약하여 표시하는 별도의 비트`들을 두는 방법으로, ARM 명령어 집합은 이 방법을 사용한다.
    - 별도의 비트들은 `컨디션 코드` 또는 `플래그`라 불리며, 산술연산의 결과가 음수인지 아닌지 또는 0인지 아닌지, 오버플로가 발생했는지 등을 알려준다.
    - 조건부 분기 명령어는 이 컨디션 코드들의 조합을 이용하여 원하는 테스트를 수행한다.
    - 단점: 많은 명령어들이 항상 컨디션 코드를 설정한다면 종속성 문제가 일어나서 파이프라인 실행을 어렵게 만들 수 있다.

### 하드웨어/소프트웨어 인터페이스
- 분기 명령어로 끝나는 명령어 시퀸스는 컴파일러에게 특히 중요한 의미가 있어 `기본 블록`(basic block)이라는 별칭이 붙어 있다. 
- 기본 블록이란 분기 명령을 포함하지 않으며(맨 끝에는 있을 수 있다.) 분기 목적지나 분기 레이블로 없는 (맨 앞에 있는 것을 허용) 시퀸스이다.
- 컴파일의 초기 단계 작업 중 하나는 프로그램을 기본 블록으로 나누는 일이다.


## 빠른 경계 검사 방법
- 부호있는 정수를 부호없는 정수처럼 다루면 0<= x < y 검사 비용을 낮출 수 있는데,  <br />
이 검사는 `인덱스가 배열의 한계를 벗어났는지 확인`하는 검사에 딱 맞는다.
- 핵심은 2의 보수로 표현된 음수가 부호없는 정수에서의 큰 수처럼 보인다는 것이다. <br />
즉, 2의 보수 표현에서 MSB가 부호 비트이지만 부호없는 정수에서는 `큰 값`을 의미한다. <br />
따라서 부호없는 비교 x < y를 하면, `x가 y보다 작은지` 뿐만 아니라 `x가 음수인지`도 검사할 수 있다.

### 활용
- 다음에서 인덱스가 경계를 넘는지 검사하는 데 필요한 명령어 수를 줄여라 <br />
x20 >= x11이거나 x20이 음수이면 IndexOutOfBounds로 분기하라. <br />

- 크거나 같은지 `부호없는 비교(bgeu)`를 이용하면 두 가지 검사를 단번에 할 수 있다.
bgeu x20, x11, IndexOutOfbounds // if x20 >= x11 or x20 < 0, goto IndexOutOfBounds

## Case/Switch 문장
- 1. switch를 구현하는 가장 간단한 방법은 `계속적인 조건 검사`를 통해 switch를 `if-then-else의 연속`으로 바꾸는 것이다. <br />
- 2. 그러나 여러 코드의 시작 주소를 표로 만들면 더 효율적으로 구현할 수 있다. <br />
이때 프로그램은 `분기 주소 테이블`(branch address table )또는 `분기 테이블`(branch table)의 인덱스만 계산해서 해당 루틴으로 분기할 수 있다. <br />
    - 분기 테이블: 프로그램상의 `레이블`에 해당하는 주소를 저장하고 있는 더블워드 배열이다. <br />
    프로그램은 분기 테이블로부터 적당한 주소를 레지스터에 적재한 후 레지스터의 주소를 사용하여 분기한다. <br />
    RISC-V 같은 컴퓨터들은 이런 상황을 다루기 위해 `indirect jump 명령어`를 갖고 있다. <br />
    이 명령어는 레지스터에 명시된 주소로 무조건 분기한다.  RISC-V에서는 jair(jump-and-link-register) 명령어가 이 역할을 한다.

### 하드웨어/소프트웨어 인터페이스
- C나 자바 같은 프로그래밍 언어에는 많은 `판단`과 `순환문`이 있지만 <br />
그 명령어 집합 계층에서 이것을 구현하는 기반은 `조건부 분기`이다.
