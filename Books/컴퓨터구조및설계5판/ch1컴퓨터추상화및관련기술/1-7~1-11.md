# 1.7 전력 장벽
- `속도`와 `전력`는 서로 관련이 있어 함께 증가한다
- `클럭 속도`와 `소비 전력`이 수십년간 빠르게 증가하다 최근에 주춤해진 이유는 <br />
상용 마이크로프로세서의 냉각 문제 때문이다.
- 새로운 공정이 나올 때마다 `전압`은 낮아졌고, `전력`은 전압의 제곱에 비례하기 때문에 `소비 전력`이 낮아졌다.<br />
하지만 문제는 더 이상 전압을 낮추면` 트랜지스터 누설 전류`가 너무 커진다는 것이다. <br />
서버 칩에서는 이미 40%의 전력이 누설에 의해 소모되고 있다.

-  컴퓨터 설계자들이 이러한 전력 장벽에 부딪쳤기 때문에 앞으로 나아가기 위해서 초창기 30년 동안 마이크로프로세서를 설계하던 것과 `다른 방식`을 선택했다.

# 1.8 현저한 변화: 단일프로세서에서 멀티프로세서로의 변화
- 단일프로세에서 한 프로그램의 응답시간을 계속 줄여 나가는 대신, `칩에 여러 개의 프로세서를 직접한 마이크로프로세서`를 생산했다. <br />
이는 응답시간보다 `처리량 개선`에 더 효과가 있다.

- 두 용어의 혼란을 줄이기 위해 회사들은 프로세서를 "코어"라고 부르고 <br />
그러한 마이크로프로세서를 멀티코어 마이크로프로세서라고 불렀다. <br />
ex) "쿼드코어" 마이크로프로세서는 4개의 프로세서 즉 4개의 코어를 포함한 칩이다.

- 오늘날 응답시간을 현저히 개선하려면 `다중 프로세서의 장점을 살리도록` 프로그램을 재작성해야한다. <br />
`파이프라이닝`은 명령어의 실행을 중첩해 프로그램을 빠르게 실행시키는 훌룡한 기술로, 명령어 수준 병렬성의 한 예다.<br />
파이프라이닝에서는 하드웨어의 병렬적인 특성이 드러나지 않기 때문에<br />
프로그래머와 컴파일러는 하드웨어가 명령어를 순차적으로 실행시키는 것으로 여길 수 있다.

## 명시적 병렬 프로그램을 작성하는 것이 어려운 이유
- 1. 병렬 프로그래밍은 정의상 `성능을 중시하는 프로그래밍`이고 이것이 프로그래밍의 어려움을 가중시킨다.
    - 프로그램이 정확하고, 중요한 문제를 해결하며, 편리한 인터페이스를 제공하고, 실행시간까지 빨라야 하기 때문이다

- 2. 병렬 하드웨어에서 빠르게 수행된다는 것은 각 프로세서가 `비슷한 양의 일`을 `동시에 수행`하도록 응용을 `분할`해야 하고, <br />
이것으로 얻을 수 있는 잠재적인 성능의 이득을 침해하지 않도록 `분할된 일`을 `스케줄링`하고 `조정`하는 `오버헤드`가 작아야 함을 의미하기 때문이다.
    - 하나의 코어가 다른 코어들 보다 시간을 많이 소비하거나 , <br />
    자신들의 일을 수행하기 위해 다른 코어들과 너무 오래 통신을 하면 병렬프로그램의 이점이 줄어든다. <br />
    따라서  `스케줄링`, `부하 균형`, `동기화 시간`, `통신 오버헤드`를 줄여야한다.
    
# 1.10 오류 및 함정
    
## 오류 - 공통적으로 잘못 알고 있는 부분
- 이용률이 낮은 컴퓨터는 전력 소모가 작다고 생각한다.
- 성능에 초점을 둔 설계와 에너지 효율에 초점을 둔 설계는 서로 무관하다.
    - 어떤 하드웨어나 소프트웨어 최적화 기술이 에너지를 더 소비하더라도 실행시간을 줄여서 전체 에너지를 절약하기도 한다.
    
    ## 함정 - 흔히 저지르기 쉬운 실수
- 컴퓨터의 한 부분만 개선하고 그 개선된 양에 비례해서 전체 성능이 좋아지리라고 기대한다.
- 성능식의 일부분을 성능의 척도로 사용한다.
    - 클럭 속도, 명령어 개수, CPI 하나 또는 두 개(제한된 상홍에서 타당한 경우도 있음)만 사용하여 성능을 비교하는 것은 위험하다.
    


