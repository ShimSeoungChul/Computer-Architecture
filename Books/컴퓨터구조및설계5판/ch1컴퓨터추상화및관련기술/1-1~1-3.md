# 1.1 서론
## 이책에서 배울 수 있는 것
- C나 자바 같은 상위 수준 수준 언어로 작성된 프로그램이 어떻게 하드웨어 언어로 번역되며, <br />
하드웨어는 번역된 프로그램을 어떻게 실행하는가?
    - 프로그램 성능에 영향을 미치는 하드웨어와 소프트웨어 양쪽의 특성을 이해
- 소프트웨어와 하드웨어 사이의 인터페이스는 무엇이며, 소프트웨어는 어떻게 필요한 일을 하드웨어에게 지시하는가?
    - 여러 종류의 소프트웨어 작성 방법을 이해하는 데 중요
- 프로그램의 성능을 결정하는 요소는 무엇이며, 프로그래머는 어떻게 성능을 개선할 수 있는가?
- 성능 개선을 위해 하드웨어 설계자는 어떤 기술을 사용할 수 있는가?
- 에너지 효율성을 개선하기 위해 하드웨어 설계자는 어떤 기술을 사용할 수 있는가?
- 최근 순차적인 처리에서 병렬 처리로 넘어가는 이유는 무엇이며 그 결과는 어떠한가?
    - 이에 대한 동기와 병렬성을 지원하는 하드웨어 기법들을 설명
- 1951년에 최초로 컴퓨터가 시판된 이후 컴퓨터 구조 분야의 어떤 위대한 아이디어들이 현대 컴퓨팅의 기초를 닦았는가?

## 하드웨어와 소프트웨어가 어떻게 성능에 영향을 미치는가

|하드웨어 또는 소프트웨어 구성 요소|성능에 미치는 영향|관련 부분|
|---|-----|--|
|알고리즘|소스 프로그램 문장 수와 입출력 작업 수를 결졍|다른 책|
|프로그램밍 언어, 컴파일러, 컴퓨터 구조| 각 소스 프로그램 문장에 해당하는 기계어 명령어 수 결졍| 2,3장 |
|프로세서와 메모리 시스템|명령어의 실행 속도 결정|4,5,6장|
|입출력 시스템(하드웨어 및 운영체제)|입출력 작업의 실행 속도 결정|4,5,6장|

- 이 책의 여러 아이디어가 성능에 미치는 영향을 보여 주기 위해 행렬과 벡터를 곱하는 <br />
C프로그램의 성능을 여러 장에 걸쳐서 개선한다

- 각 단계는 오늘날 마이크로프로세서에서 사용되는 하드웨어가 어떻게 200배의 성능 개선을 가져오는지 잘 이해할 수 있게 해준다
    - 데이터 수준 병렬성: C intrinsic을 통해 서브워드(subword) 병렬성 사용, 3.8배 성능 개선
    - 명령어 수준 병렬성: 다중 명령어 내보내기, 비순차 실행 하드웨어 활용을 위한 순환문 펼치기 사용, 2.3배 성능 개선
    - 메모리 계층 최적화: 캐시 블로킹을 이용하여 큰 행렬의 경우 2~2.5배 성능 개선
    - 스레드 수준 병렬성: OpenMp의 parallel for 순환문을 써서 멀티코어 하드웨어 활용, 4~14배 성능 개선
    
# 1.2 컴퓨터 구조 분야의 8가지 위대한 아이디어
## Moore의 법칙을 고려한 설계
- 매 18~24개월마다 칩에 집적되는 소자의 소가 2배가 된다
- 컴퓨터 설계자는 프로젝트의 시작 시점보다 종료 시점의 기술을 예상해야 한다

## 설계를 단순화하는 추상화
- 하드웨어와 소프트웨어의 생산성을 높이는 핵심 기술 중 하나는 여러 가지 계층에서 설계를 특징짓는 추상화를 사용하는 것이다. 하위 수준의 상세한 사항을 안보이게 함으로써 상위 수준 모델을 단순화한다.
- 개발 이유: 무어의 법칙에 따라 자원의 수가 급격히 증가함에 따라 설계시간이 길어지는 것을 방지하기 위해서<br />

## 자주 생기는 일을 빠르게
- 자주 생기는 일을 빠르게 만드는 것이 드물게 생기는 일을 최적화하는 것보다 성능 개선에 도움이 된다.
- 또한 드물게 생기는 일보다 단순하여 성능 개선이 쉬운 경우가 많다.

## 병렬성을 통한 성능 개선

## 파이프라이닝을 통한 성능 개선
- 컴퓨터 구조에서 많이 볼 수 있는 병렬성의 특별한 형태이다.
- 사람들이 길게 늘어서서 양동이로 물을 나르면, 각자 양동이를 들고 왔다 갔다 하는 것보다 훨씬 빨리 물을 나를 수 있는 것과 같다.

## 예측을 통한 성능 개선
- 예측을 잘못해서 이를 복구하는 비용이 비싸지 않고 예측 성공 확률이 비교적 높은 경우, <br />
예측을 해서 미리 일을 수행하는 것이 빠른 경우가 있다.

## 메모리 계층구조
- 프로그래머는 빠르고 크고 값싼 메모리를 원한다. 컴퓨터 설계자들은 이렇게 상충되는 요구를 메모리 계층구조로 해결한다.
- 최상위 계층에는 비트당 가격이 제일 비싸지만 작고 빠른 메모리, 최하위 계층에는 느리지만 크고 비트당 가격이 제일 싼 메모리를 사용한다.

## 여유분을 이용한 신용도 개선 
- 컴퓨터는 빠르기만 해서는 안 되고, 신뢰할 수 있어야 한다. 
- 모든 물리 소자는 장애가 발생할 수 있으므로, 장애를 감지하고 장애가 난 소자를 대치할 수 있도록 <br />
여유분을 준비하면 컴퓨터의 신용도를 개선할 수 있다.

# 1.3 프로그램 밑의 세계
- 컴퓨터 하드웨어는 아주 단순한 저수준의 명령어만을 실행할 수 있다. <br />
복잡한 응용 프로그램에서 출발해서 단순한 명령어까지 내려가려면 높은 수준의 작업을 <br />
단순한 컴퓨터 명령어로 번역 또는 해독하는 `여러 겹의 소프트웨어`가 필요하다.
이것이 `추상화`의 한 예다.

- 이러한 소프트웨어들은 계층적으로 구성되며, <br />
응용 프로그램이 가장 바깥쪽에 위치하며, 여러 가지 `시스템 소프트웨어`가 `하드웨어`와 `응용 소프트웨어` 사이에 존재한다.
![소프트웨어계층구조](https://user-images.githubusercontent.com/40673012/93276536-c65ba180-f7fa-11ea-81c9-59695e605209.jpg)

## 시스템 소프트웨어
- 시스템 소프트웨어는 여러 가지가 있으나, 오늘날 모든 컴퓨터 시스템에서 핵심이 되는 구 가지는 <br />
`운영체제`와 `컴파일러`이다.

### 운영체제
- 사용자 프로그램과 하드웨어 간의 `인터페이스 역할`을 하면서 `각종 서비스`와 `감독` 기능을 한다.
    - 기본적 입출력 작업의 처리
    - 보조기억장치 및 메모리 할당
    - 컴퓨터를 동시에 사용하는 여러 응용 프로그램들 간의 컴퓨터 공유 방법 제공

### 컴파일러
- C, C++, 자바 같은 상위 수준 언어로 작성된 프로그램을 `하드웨어가 실행할 수 있는 명령어로 번역`하는 일을 한다.


## 기계어
- 전자장비와 직접 대화하기 위해서는 `전기 신호`를 보내야 한다. <br />
기계가 이해할 수 있는 가장 쉬운 신호는 on, off이다. 따라서 기계 언어는 0, 1 두 종류의 문자로 되어 있다.

- 컴퓨터는 우리의 지시에 따라서 일하는 종이라 볼 수 있는데, 이 지시를 `명령어(instruction)`라고 한다.
명령어는 `컴퓨터가 이해할 수 있는 비트들의 집합`에 불과하므로, 이것을 숫자로 생각할 수 있다.
예를 들어 1001010100101110이 어떤 컴퓨터에게는 두 숫자를 더하라는 명령이 된다.

- 명령어와 데이터를 숫자로 표시하는 것이 컴퓨터의 기초이다 (이러한 구조의 이유는 2장에서 다룬다)

## 어셈블리 언어

- 초창기 프로그래머들은 컴퓨터와 이진수로 대화하였으나, <br />
`곧 사람이 생각하는 것과 비슷한 새로운 표시 방법`을 고안했다.<br />
처음에는 이 표시 방법으로 표현된 프로그램을 사람이 일일이 이진수로 번였했으나, <br />
얼마 후 이런 `기호식 표현을 이진수로 바꾸는 프로그램`이 발명되어 컴퓨터에 프로그램하는 것을 컴퓨터
자신이 도와주도록 만들었다. <br />
이러한 프로그램을 `어셈블러(assembler)`라 불렀다.

- 예를 들어 프로그래머가 add A, B라고 쓰면 어셈블러가 이것을 <br />
100101010010110으로 바꾼다.

- 이러한 기호 형태의 언어를 `어셈블리 언어`라 하고, 오늘날에도 계속 사용된다.

### 어셈블리 언어의 한계
- 어셈블리 언어는 컴퓨터가 수행할 명령어를 한 줄에 하나씩 써야 하기 때문에 <br />
프로그래머에게 `기계식 사고방식`을 강요한다는 단점이 있었다.
- 예를들어 과학자가 유체의 흐름을 표현하는 데 사용하는 표기법이나, <br />
회계사가 대차대조표를 정리하는 데 사용하는 표기법 등과는 거리가 멀었다.

## 상위 수준 언어 

- 어셈블리 언어의 한계를 극복하기 위해 프로그램을 고성능 언어로 작성하고, <br />
나중에 컴퓨터 명령어로 번역할 수 있게 되었다.

- 오늘날 프로그래머가 정신 건강을 잃지 않으면서도 높은 생산성을 유지할 수 있는 것은 `상위 수준 언어`와 이것을 어셈블리 언어로 번역하는 `컴파일러`가 있기 때문이다.

- 아래 그림으로 프로그램과 언어 간의 이러한 관계를 볼 수 있고, 이것이 `추상화`의 위력을 보여 주는 또 다른 예이다.

![상위언어에서기계어로](https://user-images.githubusercontent.com/40673012/93276128-c018f580-f7f9-11ea-9869-bc98ff9cf810.png)

    
### 상위 수준 언어의 장점
- 1. 프로그래머가 영어 단어와 수학 기호를 사용해서 `자연스러운 언어`로 생각할 수 있게 하며, <br />
작성된 프로그램도 이상한 부호로 된 표 형태보다 일반 문장과 훨씬 비슷한 읽기 좋은 모양이 된다. <br />
또한 `사용 목적`에 적합한 언어가 다양하게 설계될 수 있다. <br />
예를 들어 포트란은 과학 계산용, 코볼은 업무 자료 처리용, 리스프는 기호 조작용으로 설계되었다. <br />

- 2. 프로그래머의 `생산성`을 높여 준다.
    - 어떤 아이디어를 표현하기 위해 필요한 문장 수가 적으면 적을수록 개발 기간이 단축된다 (간결성)<br />
    
- 3. 프로그램을 개발한 기종과 상관없이 `어느 컴퓨터에서든 실행`이 가능하다. <br />
    - 컴파일러나 어셈블러가 상위 수준 언어 프로그램을 어떤 컴퓨터의 기계어로도 번역할 수 있기 때문

