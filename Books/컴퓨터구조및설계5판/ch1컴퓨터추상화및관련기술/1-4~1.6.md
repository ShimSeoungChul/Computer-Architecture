# 1.4 케이스를 열고

- 모든 컴퓨터의 하드웨어는 데이터 `입력`, 데이터 `출력`, 데이터 `처리`, 데이터 `저장`의 네 가지 기본 기능을 수행한다. <br />
이 기능을 수행하는 방법이 이 책의 가장 중요한 주제이다.

- 컴퓨터의 주요 구성 요소 중에 `입력장치`(마이크 등)와 `출력장치`(스피커 등)가 있다. <br />
입력장치는 `컴퓨터에 데이터를 공급`하고, 출력장치는 사용자에게 `계산 결과를 보여` 준다. <br />
무선 네트워크처럼 입출력을 겸하는 장비도 있다.

## 디스플레이

### LCD
- 대부분의 개인 휴대용 기기들은 `얇고 전력 소모가 적은 LCD(Liquid Crystal Display)`를 사용한다
- LCD는 스스로 빛을 내는 대신 통과하는 `빛을 제어`한다
- 전형적인 LCD에는 `액체 상태의 막대 모양 분자`가 디스플레이어에 들어오는 `빛을 굴절`시킨다
- 빛은 보통 디스플레이 뒤쪽의 `광원`에서 보내지며, 반사광을 이용하는(흔하지 않음) 경우도 있다
- 이 막대들은 보통때는 꼬인 나선형 모양으로 배열되어 빛을 굴절시키다, 전류를 흘리면 똑바로 펴져서 빛을 통과한다. <br />
90도로 편광된 두 스크린 사이에 액정 물질을 넣기 때문에 빛이 꺾이지 않는 한 통과할 수 있다.
- 대부분의 LCD는 매 화소 위치마다 작은 `트랜지스터`를 배치하여 전류를 정밀하게 제어하는 `능동 행렬(active matrix)`를 제공한다.
- 매 화소마다` 빨-초-파 마스크`가 있어 각 원색의 강도를 결정하며, 컬러 능동 행렬 LCD에는 화소마다 세 개의 `트랜지스터 스위치`가 있다.
    
```
편광(偏光, 영어: polarization (of light))은 전자기파가 진행할 때 파를 구성하는 전기장이나 자기장이 특정한 방향으로 진동하는 현상을 가리킨다. 일반적인 의미의 전자기파는 모든 방향으로 진동하는 빛이 혼합된 상태를 말하지만, 특정한 광물질이나 광학필터를 사용해 편광된 상태의 빛을 얻을 수 있다.

https://ko.wikipedia.org/wiki/%ED%8E%B8%EA%B4%91
```    
    
### 화소
- 각 화상은 화소(pixel)의 행렬로 구성되며, 이것은 `비트맵`이라 부르는 `비트의 행렬`로 표현된다
- 디스플레이 행렬은 스크린의 크기와 해상도에 따라 1024x768에서 2048x1536개의 화소로 구성된다
- 컬러 디스플레이는 빛의 3원색(빨, 파, 초) 각각마다 8비트씩, 모두 24비트를 사용하여 수백만 가지의 색을 표시할 수 있다

### 프레임 버퍼
- 그래픽을 지원하는 하드웨어의 중심이 되는 것은 `비트맵을 기억`하는 `프레임버퍼(frame buffer 또는  raster refresh buffer)`라고 하는 부분이다. 
- 그래픽 하드웨어는 스크린에 표시될 화상을 프레임 버퍼에 저장하였다가, 기억된 각 화소의 비트 패턴을 재생 속도에 맞추어 그래픽 디스플레이로 보낸다.

### 기타 내용
- 비트맵의 목적은 스크린에 있는 화상을 충실히 나타내는 것이다. <br />
- 그래픽 시스템의 난제들은 모두 인간의 눈이 예민하기 때문에 생기는 것들이다. <br />
사람의 눈은 화면상의 미세한 변화도 아주 잘 감지하기 때문이다.


## 터치스크린
- 터치스크린을 구현하는 다양한 방법이 있는데 오늘날의 많은 태블릿은 정전용량 감지 기법을 사용한다.
- 유리 같은 `절연체` 위에 `투명한 도체를 코팅`하면, 사람이 손을 댔을 때 전기가 통하여 스크린의 `정전기장`이 찌그러지면서 `정전용량`이 변한다.

## 상자를 열고

### 프로세서(Central Processor Unit)
- 프로세서는 프로그램의 지시대로 일을 하는 부분으로 `숫자를 더하고`, `검사`하고 `입출력장치에 신호`를 보내 작동을 지시하는 것 등이 프로세서가 하는 일이다.
- 프로세서는 논리적으로 `데이터 패스`와 `제어 유닛` 두 부분으로 구성된다
- 각각은 프로세서의 `근육`과 `두뇌`에 해당한다. 데이터 패스는 `연산`을 수행하고, <br />
제어 유닛은 명령어가 뜻하는 바에 따라 데이터패스, 메모리, 입출력장치가 `할 일을 지시`한다.

### 메모리
- 실행 중인 `프로그램`과 프로그램이 필요로 하는 `데이터`를 기억한다
- 메모리는 `DRAM(Dynamic Random Access Memory) 칩`으로 구성되고, <br />
이를 여러 개 한데 묶어 `프로그램의 명령어`와 `데이터`를 기억하는 데 사용한다.
- DRAM에서 `RAM`이란 말은 자기 테이프 같은 순차 접근 메모리와는 반대로 `메모리의 어떤 부분을 읽든지 같은 시간`이 걸린다는 의미다

### 캐시 메모리
- 프로세서 내부에 있는 DRAM과  다른 종류의 메모리다
- `DRAM의 버퍼` 역할을 하는 `작고 빠른 메모리`다
- `SRAM(Static Random Access Memory)`이라는 다른 메모리 기술을 이용한다
- SRAM은 DRAM보다 빠르지만 집적도가 낮아서 `가격이 비싸다`
- SRAM과 DRAM은 `메모리 계층구조`의 두 계층을 구성한다.

### 명령어 집합 구조
- 하드웨어와 최하위 소프트웨어 간의 인터페이스는 제일 중요한 `추상화` 중 하나로, <br />
`명령어 집합구조(instruction set architecture)` 또는 `구조(architecture)`로 불린다.

- 명령어 집합 구조 구조에는 제대로 작동하는 이진 기계어 프로그램을 작성을 위해 프로그래머가 알아야 하는 명령어, 입출력장치 및 기타 저수준 시스템 기능등이 모두 포함된다. <br />
    이러한 세부 사항은 `운영체제`가 감추어 응용 프로그래머가 이것을 걱정하지 않도록 한다.

- 응용 프로그래머에게 제공되는 `기본 명령어 집합`과 `운영체제 인터페이스`를 합쳐서 `ABI(application binary interface)`라 한다

- 명령어 집합 구조는 `실행 하드웨어`와 독립적으로 `컴퓨터의 기능`을 생각할 수 있게 해 준다. 
    - ex) 디지털 시계의 기능(현재 시각 유지, 시각 표시, 알람 설정)을 클럭 하드웨어(수정 발진자, LED 디스플레이, 플라스틱 버튼 등)와 분리해서 생각할 수 있다.

- 이와 같이 컴퓨터 설계자는 `명령어 집합 구조`와 `구조의 구현(구조 추상화를 준수하는 하드웨어)`를 분리해서 생각한다. 이렇게 인터페이스를 추상화해 같은 소프트웨어를 실행하지만 가격과 성능이 다른 여러 가지 컴퓨터를 구현할 수 있다.

## 데이터의 안전한 저장소
- 실행되는 동안 데이터와 프로그램을 기억하는(전원이 끊어지면 내용 삭제) `휘발성 메모리(volatile)`를 `메인 메모리` 또는 `1차 메모리(primary memory)`,<br />
  다음번 실행때까지 데이터와 프로그램을 저장하는 `비휘발성 메모리(nonvolatile)`는 `보조기억장치(secondary memory)`라고 한다.

- 보조기억장치는 `메모리 계층구조`에서 메인 메모리보다 한 단계 아래 계층

- 1975년 이래 `DRAM`이 메인 메모리의 주종을 이루고, <br />
`자기 디스크`는 그 이전부터 보조기억장치로 널리 쓰였다. <br />
`개인 휴대용 기기`는 크기와 모양의 제약으로 자기 디스크 대신 `비휘발성 반도체 메모리인 플래시 메모리`(PMD의 표준)를 사용한다.

- 플래시 메모리는 DRAM보다 느리지만 훨씬 싸고 비휘발성이라는 장점이 있다. <br />
디스크보다 비트당 단가는 비싸지만, 작고 튼튼하고 전력 소모가 작으며 훨씬 `소용량으로 생산` 가능하다.<br />
하지만 자기 DRAM, 자기 디스크와 달리 100,000번~1,000,000번 쓰기를 한 후에는 못 쓰게 된다. <br />
때문에 `쓰기 횟수를 파악`하여 `저장 기능이 상실`되는 것을 피하도록 많이 사용되는 데이터를 이동시키는 등의 정책을 사용한다.

## 컴퓨터 간의 통신

- 네트워크의 연결 거리와 성능은 여러 가지이나, `통신 속도가 빨라`지거나 `전송 거리가 멀어`질 때 `통신비용이 상승`하는 것은 공통이다.

### 이더넷(Ethernet)
- 이더넷으로 연결할 수 있는 거리는 대략 1km 정도이고, 초당 40기가비트를 전송할 수 있다.

- 이런 정도의 길이와 속도는 한 건물의 같은 층에 있는 컴퓨터들을 연결하는 데 유용하다. <br />
즉, 이더넷은 `근거리 네트워크(local area network, LAN)`의 일종이다.

- 라우팅 서비스와 보안을 제공하는 스위치를 사용하면 LAN들을 서로 연결할 수 있다.

### 원거리 네트워크(wide area network, WAN)
- 원거리 네트워크는 여러 대륙을 연결하여 `웹(World Wide Web)`을 지원하고 있는 인터넷을 근간으로 이룬다.
- 이런 네트워크는 보통 `광섬유(optical fiber)`로 구성하며 통신회사에서 입대해 준다.

### 네트워크로 컴퓨터들을 연결하는 장점
- 1. 통신: 컴퓨터끼리 고속으로 정보를 주고받을 수 있다
- 2. 자원 공유: 컴퓨터마다 입출력장치를 따로 갖출 필요 없이 네트워크상의 모든 컴퓨터가 입출력장치를 공유
- 3. 원격 접근: 컴퓨터들을 연결하면 멀리 떨어져 있는 컴퓨터도 쉽게 이용

# 1.6 성능
- 어떻게 성능을 측정한는 것이 가장 좋은 방법이며, 성능 측정 방법의 한계는 무엇인지를 이해하는 것이 기종 선장에 매우 중요 하다.

- 응답 시간이 더 중요한 개인 휴대용 기기와 처리량이 더 중요한 서버의 성능을 평가할 떄는 대부분 다른 응용 프로그램과 다른 성능 척도를 사용한다.

## 처리량과 응답시간

- 1. 컴퓨터의 프로세서를 더 빠른 버전으로 바꾼다.
- 2. 여러 개의 프로세서가 각기 다른 태스크를 담당하는 시스템(예: 웹 탐색)에 프로세서를 하나 추가한다.<br />

- 응답시간을 단축하면 대부분 처리량을 좋아진다. 따라서 1번의 경우 응답시간과 처리량이 모두 개선된다.<br />
2번의 경우 특정 태스크의 실행시간이 단축되는 것은 아니므로 처리량만이 개선된다.
    - 그러나 처리에 대한 요구가 처리량보다 커지면 일부는 큐에 넣어 기다리게 된다. <br />
    이 경우 처리량이 커지면 큐에서 기다리는 시간이 짧아지므로 응답시간도 개선된다.<br />
    이와 같이 대부분의 실제 컴퓨터에서 실행시간이나 처리량 중 하나가 변하면 다른 쪽에도 영향을 미친다.
    
- 본서의 전반부에서 컴퓨터의 성능을 논할 떄 주로 응답시간에 초점을 맞출 것이다. 성능을 최대화하려면 어떤 태스트의 응답시간 또는 실행시간을 최소화 해야 한다.

## 성능의 측정
- 거의 모든 컴퓨터는 하드웨어 이벤트가 발생하는 지점을 결정하는 `클럭`을 이용하여 만들어진다.
- 이 클럭의 시간 간격을 `클럭 사이클`(또는 `틱`, `클럭 틱`, `클럭 주기`, `클럭`, `사이클`)이라 한다. <br />
클럭 주기는 한 클럭 사이클에 걸리는 시간(ex 250ps)이나 클럭 속도(ex 4GHz)로 표시한다.<br />
`클럭 속도`는 `클럭 주기의 역수`이다.

## CPU 성능과 성능 인자
- 컴퓨터의 성능을 표시하는 데 사용자가 사용하는 척도와 설계자가 사용하는 척도가 서로 다른 경우가 많다.
<br /> 이때 서로 다른 척도 간의 상관관계를구할 수 있다면, 설계상의 변화가 사용자가 느끼는 성능에 얼마나 영향을 미치는지 평가할 수 있다.

- 가장 기본적인 척도인 `클럭 사이클 수`와` 클럭 사이클 시간`으로 CPU를 표시하면 다음과 같다<br />
프로그램의 CPU 실행시간 = 프로그램의 CPU 클럭 사이클 수 x 클럭 사이클 시간  <br /> 
프로그램의 CPU 실행시간 = 프로그램의 CPU 클럭 사이클 수 / 클럭 속도

- 클럭 사이클의 길이를 줄이거나 프로그램 실행에 필요한 클럭 사이클 수를 줄이면 성능을 개선할 수 있지만, 이 둘 중 하나를 감소시키면 다른 하나가 증가하는 경우가 많다.

## 명령어 성능
- 컴파일러가 실행할 명령어를 생성하고 컴퓨터는 이 명령어를 실행해야 하기 떄문에, <br />
실행시간은 프로그램의 명령어 수와 관련이 있다.<br />
이런 관점에서 `실행시간`을 `실행 명령어 수`에 `명령어의 평균 실행시간`을 관한 값으로 계산할 수 있다. <br />
CPU 클럭 사이클 수 = 명령어 수 x 명령어 당 평균 클럭 사이클 수

- `명령어당 클럭 사이클 수 (Clock cycles Per Instruction)`는 CPI로 줄여 쓰기도 한다. <br />
명령어 집합 구조가 같으면 프로그램에 필요한 명령어 수가 같으므로, `CPI는 서로 다른 구현을 비교하는 한 가지 기준`이 될 수 있다.

## 고전적인 CPU 성능식
- 성능식을 `명령어 개수`(프로그램이 실행한 명령어의 개수), `CPI`, `클럭 사이클 시간`으로 표현하면 <br />
CPU 시간 = 명령어 개수 x CPI x 클럭 사이클 시간<br />

클럭 속도는 클럭 사이클 시간의 역수이므로, <br />
CPU 시간 = 명령어 개수 x CPI / 클럭 속도<br />

- 위 공식을 이용해 `두 가지 서로 다른 구현을 비교`할 수 있고, <br />
어떤 설계 대안이 이 세 인자에 미치는 영향을 알면 이 `설계 대안을 평가`하는 것도 가능

- 한 가지 인자만으로 성능을 평가하면 위험하므로 <br />
두 컴퓨터를 비교할 때는 실행시간에 영향을 미치는 `세 가지 인자 모두 고려`해야 한다

### 성능식의 세 가지 인자값을 구하는 방벙
- `CPU 실행시간`은 실제 프로그램을 실행시켜 얻고, <br />
`클럭 사이클 시간`은 보통 컴퓨터의 하드웨어 매뉴얼에 기록되어 있고, <br />
클럭 속도와 CPU 실행시간을 알 때 `명령어 개수`나 `CPI` 중 하나를 알면 다른 하나는 계산으로 구할 수있다<br />

- `명령어 개수`는 실행 과정을 추적하는 `소프트웨어 도구`나 컴퓨터 구조의 `시뮬레이터`를 이용해서 측정할 수 있다. <br /> 
그 외에 `하드웨어 카운터`를 사용하면 실행 명령어 수나 평균 CPI, 심지어 성능 저하의 원인까지 찾아낼 수 있다.   <br />

- `명령어 개수`는 구조에 따라서 결정되고 구현 방법과는 상관이 없어, 자세한 구현 내용은 몰라도 구할 수 있지만, <br /> 
`CPI`는 프로그램 실행에 사용되는 `명령어 배합`(instruction mix)뿐 아니라 `메모리 시스템`과 `프로세서 구조`를 포함하는 여러 가지 `컴퓨터 설계`에 따라 달라진다. <br />
따라서 `CPI`는 명령어 집합이 같아도, 구현 방식, 응용 프로그램에 따라서 다르다.<br />


### CPU 성능식 인자에 영향을 미치는 요소들

#### 알고리즘
- 영향을 받는 인자: 명령어 개수, CPI
- 어떻게? 알고리즘은 소스 프로그램이 수행할 명령어의 수, 결국 프로세서가 수행할 명령어의 수를 결정한다.
알고리즘이 `빠른 명령어`를 선호하느냐 `느린 명령어`를 선호하느냐에 따라 CPI에 영향을 미칠 수도 있다.<br />
ex) 나눗셈을 많이 하는 알고리즘은 높은 CPI를 갖게 된다.

#### 프로그래밍 언어
- 영향을 받는 인자: 명령어 개수,CPI
- 어떻게? 프로그래밍 언어로 표현된 문장은 `프로세서 명령어`로 변환되기 때문에 명령어 개수에 영향을 미친다.<br />
또한 CPI에도 영향을 미칠 수 있다.<br />
ex) 자바같이 데이터 추상화를 많이 사용하는 언어는 함수의 간접 호출(indirect call)을 필요로 하는데, <br />
이는 CPI가 높은 명령어를 사용한다

#### 컴파일러
- 영향을 받는 인자: 명령어 개수, CPI
- 어떻게? 컴파일러는 소스 언어를 컴퓨터 명령어로 `변환`하는 역할을 하므로 얼마나 효율적인가에 따라 <br />
명령어 개수와 CPI가 영향을 받는다. <br />
컴파일러의 기능이 매우 복잡한 만큼 CPI에 복잡한 방법으로 영향을 끼친다.

#### 명령어 집합 구조
- 영향을 받는 인자: 명령어 개수, 클럭 속도, CPI
- 어떻게?  명령어 집합 구조는 어떤 기능을 수행하기 위해 필요한 명령어의 수, 각 명령어당 사이클 수,<br />
프로세서의 클럭 속도에 영향을 미치므로 CPU 성능의 세 인자에 모두 영향을 미친다.


