# 4.3 데이터패스 만들기
- 데이터패스는 프로세서 안에서 데이터를 가지고 연산하거나 데이터를 저장하는 기능 유닛이다. <br />
RISC-V 구현에서는 데이터 패스 구성 요소에 명령어 메모리, 데이터 메모리, 레지스터 파일, ALU, 덧셈기 등이 포함된다.

- 그림 4.5a는 프로그램의 명령어를 저장하고 주소가 주어지면 해당 명령어를 보내 주는 `메모리 유닛`이다.
- 그림 4.5b는 `프로그램 카운터`(PC)다. PC는 현재 명령어의 주소를 가지고 있는 레지스터다.
- 그림 4.5c은 `덧셈기`이고, PC를 다음 명령어 주소로 증가시킨다. 이 덧셈기는 조합회로이며, ALU가 항상 덧셈을 하도록 제어선을 연결하여 만든다. 이런 ALU는 영구히 덧셈기로 만들어져 다른 ALU 기느을 수행할 수 없어, 그림 4.5c처럼 Add라는 레이블을 붙인다.  

<img width="497" alt="그림4-5" src="https://user-images.githubusercontent.com/40673012/100285849-f4a4ec80-2fb4-11eb-90f9-e0c2abee0b0e.png">


- `그림 4.6`은 그림 4.5의 세 가지 구성 요소를 어떻게 합쳐서 명령어를 인출하고 PC를 증가시켜 다음 명령어의 주소를 구하는 데이터패스를 만드는지 보여 준다.
    - 명령어 실행을 위해 메모리에서 명령어를 가져오는 것으로 시작해서 다음 명령어 실행 준비를 위해 프로그램 카운터가 다음 명령어를 가리키도록 4만큼 증가시킨다.

<img width="491" alt="그림4-6" src="https://user-images.githubusercontent.com/40673012/100285848-f40c5600-2fb4-11eb-82ac-5fefd55d1492.png">

### R-형식 명령어
- 모든 R-형식 명령어들은 두 개의 레지스터를 읽고 레지스터 내용에 ALU 연산을 수행하며 그 결과를 레지스터에 쓴다. 이러한 명령어들을 `R-형식 명령어` 또는 `산술/논리 명령어`라 부른다. add, sub, and, or 명령어 등
    - 예) add x1, x2, x3 // x2와 x3을 읽고 x1에 쓴다.

- 프로세서의 범용 레지스터 32개는 `레지스터 파일`이라고 하는 구조 속에 들어 있다. 파일 내의 레지스터의 번호를 지정하면 어느 레지스터라도 읽고 쓸 수 있다. 레지스터 파일은 컴퓨터의 레지스터 상태를 갖고 있다.

- R-형식 명령어들은 레지스터 피연산자 세 개를 가지고 있다. 때문에 매 명령어마다 레지스터 파일에서 두 데이터 워드를 읽고 데이터 워드 하나를 써야 한다. 
- 레지스터에서 데이터 워드를 `읽기` 위해서는 읽을 레지스터 번호를 지정하는 입력과 레지스터에서 읽을 값을 내보내는 출력필요하다. 즉, `입력`과 `출력`이 하나씩 필요하다.
- 데이터 워드를 `쓰기`위해서는 입력이 두 개 필요하다. 쓸 레지스터 번호를 지정하는 `입력`,  레지스터에 쓸 데이터값을 제공하는` 입력` <br />

- 레지스터 파일은 Read register 입력에 실리는 번호에 해당하는 레지스터의 내용을 항상 출력한다. <br />
그러나 쓰기는 쓰기 `제어신호`에 의해 제어되므로 클럭 에지에서 쓰기가 일어나려면 이 제어신호가 인가되야 한다. <br />
따라서 전체적으로 입력 4개(레지스터 번호 3개와 데이터 1개)와 출력 2개(모두 데이터)가 필요하다.  <br />
그림 `4.7a`는 이를 보여준다.
- 레지스터 번호 입력은 32개의 레지스터 중 하나를 지정해야 하므로 5비트(32=2^5) 크기다. <br />
반면에 데이터 입력과 데이터 출력 버스는 64비트 폭을 가진다.
- 그림 `4.7b`는 `ALU`를 보여 준다. ALU는 64비트 입력 두 개를 받아 64비트 결과와 결과가 0이 아닌지 나타내는 1비트 신호를 만든다.

### ld 명령어와 sd 명령어
- RISC-V의 ld(load doubleword) 명령어와 sd(store soubleword) 명령어는 ld x1, offset(x2) 또는 sd x1, offset(x2)와 같은 형식을 갖는다.
- 이 명렁어들은 `베이스 레지스터`(여기서는 x2)와 명령어에 포함되어 있는 12비트 `부호있는 변위 필드`를 더하여 메모리 주소를 계산한다.
- 저장 명령어는 저장할 값을 레지스터 파일에서 읽어 온다. 이 값은 x1에 있다.  적재 명령어이면 메모리에서 읽어 들인 값을 지정된 레지스터(x1)에 써야 한다.
- 따라서 그림 4.7 레지스터 파일과 ALU 둘 다 필요하다. 그 외에도 명령어의 12비트 변위 필드 값을 64비트 부호있는 값으로 `부호확장`(sign extension)하기 위한 유닛이 필요하며, 읽고 쓸 데이터 메모리도 필요하다. 

<img width="498" alt="그림4-7" src="https://user-images.githubusercontent.com/40673012/100285846-f373bf80-2fb4-11eb-912c-8c51a5e1bb26.png">

- `데이터 메모리`는 저장 명령어일 떄만 쓰기를 해야 한다. 따라서 데이터 메모리는 `읽기 제어신호`와 `쓰기 제어신호`, `주소 입력`, `메모리에 쓸 데이터 입력`이 필요하다. 그림 4.8은 `수치 생성 유닛`과  `데이터 메모리`를 보여 준다.

### beq 명령어
- beq 명령어는 세 개의 피연산자를 갖으며, 두 개의 레지스터와 12비트 변위로 구성된다. 
- `두 개의 레지스터`는 같은지 비교하기 위한 피연산자이다.
- `12비트 변위`는 분기 명령어 주소에 대한 상대적인 `분기 목적지 주소`(branch target address)를 계산하는 데 사용되는 값이다.
- 명령어 형태: beq x1, x2, offset 
- 명령어 구현을 위해 PC값에 명령어 변위 필드를 부호확장한 값을 더해서 분기 목적지 주소를 계산해야 한다.
- 분기 명령어 정의시 주의사항:
    - 1.  분기 주소 계산의 베이스 주소는 분기 명령어 주소라고 명령어 집합 구조가 명시하고 있다.
    - 2. 변위 필드는 1비트만큼 왼쪽 자리이동 하여 하프워드 변위가 된다는 것도 명령어 집합 구조에 포함되어 있다. <br />
    이렇게 함으로써 변위 필드의 유효 범위가 두 배 증가한다.<br />
    

    <img width="498" alt="그림4-8" src="https://user-images.githubusercontent.com/40673012/100285845-f2429280-2fb4-11eb-8cef-6ec82fe621a7.png">
    
    
- 위에 두 번째 문제를 다루기 위해 변위 필드를 1비트 자리이동시켜야 한다.
- 분기 목적지 주소를 계산하는 것 외에 다음에 실행할 명령어가 바로 뒤에 있는 명령어가 될지 아니면 분기 목적지 주소에 있는 명령어가 될지 판단해야 한다.
- 조건이 사실일 때(두 피연산자 값이 같은 때) 분기 목적지 주소가 새로운 PC값이 되면 분기가 일어났다(branch is taken)이라고 말한다.
- 따라서 분기 데이터패스는 분기 목적지 주소를 계산하고 레지스터 내용을 비교하는 두 가지 일을 해야 한다. 
- 그림 4.9는 분기를 다루는 데이터패스 부분이다.
- 분기 목적지 주소를 계산하기 위해서 분기 데이터패스는 수치생성 유닛(그림 4.8)과 덧셈기를 포함한다. <br />

<img width="501" alt="그림4-9" src="https://user-images.githubusercontent.com/40673012/100285840-f1116580-2fb4-11eb-9cce-71c6a7fff75c.png">

- `비교`를 수행하기 위해서는 레지스터 피연산자를 제공하기위해 그림 4.7a와 같은 `레지스터 파일`이 필요하다. <br />
또한 비교 연산은 ALU를 사용한다. 
- ALU는 결과가 0인지 나타내는 출력신호를 제공한다. 때문에 두 개의 레지스터 연산자를 `뺄셈` 하라는 제어신호와 함께 ALU에 보내게 된다.
- ALU의 Zero 신호가 인가되면 레지스터값이 같다는 걸 알 수 있다.  <br />

- `분기`(branch) 명령어는 명령어의 변위 12비트를 1비트만큼 왼쪽으로 자리이동한 후 PC에 더한다. <br />
자리이동은 분기 변위 뒤에 0만 덧붙이면 된다.

## 단일 데이터패스 만들기
- 앞서 데이터패스 구성 요소를 알아보았다. 여기에 제어를 첨가하여 구현을 완성하자.
- 가장 간단한 데이터패스는 모든 명령어를 한 클런 사이클에 실행하도록 시도하는 것이다.  <br />
즉, 어느 데이터패스 자원도 명령어당 두 번 이상 사용될 수 없다. <br />
따라서 두 번 이상 사용할 필요가 있는 구성 요소는 필요한 만큼 여러 개를 두어야 한다.  <br />

- 두 개의 다른 명령어 종류들이 데이터패스 구성 요소를 `공유`하기 위해서는 그 구성 요소의 입력에 여러 개의 연결을 허용하고, `멀티플렉서`와 `제어신호`를 사용해서 그 입력들 중 하나를 선택해야 한다.

- `R-형식`(산술/논리 연산) 명령어는 ALU를 사용하되, 두 입력이 모두 레지스터에서 온다.<br />
`메모리` 명령어는 주소를 계산하기 위해 ALU를 사용하지만, ALU의 두 번째 입력은 명령어의 12비트 변위 필드를 부호확장한 값이다.
- R-형식 명령어는 목적지 레지스터에 저장할 값이 ALU에서 사요지만, 적재 명령어는 메모리에서 가져온다.<br />
- 레지스터 파일 하나와 ALU 하나만을 사용하는 데이터패스를 만들기 위해 두번째 ALUI 입력에 두 종류의 다른 근원지가 있어야한다. 또한 레지스터에 저장할 데이터 입력에도 두 개의 다른 근원지를 연결해야 한다. <br />
따라서 `ALU 입력`에 멀티플렉서 하나, `레지스터 파일의 데이터 입력`에 멀티플렉서 하나를 설치해야한다.(그림4.10) <br />

<img width="580" alt="그림4-10" src="https://user-images.githubusercontent.com/40673012/100285844-f2429280-2fb4-11eb-8543-d30d24bed92c.png">

- `그림 4.11`은 명령어 인출을 위한 데이터패스(그림4.6), R-형식 명령어와 메모리 명령어를 위한 데이터패스(그림 4.10), 분기 명령어를 위한 데이터패스(그림4.9)를 하나로 합쳐서 만든 데이터패스를 보여 준다. <br />
- 분기 명령어는 주ALU를 레지스터 피연산자 두 개가 같은지 테스트에 사용하므로 `분기 목적지 주소 계산`을 위해서는 그림 4.9의 `덧셈기`가 있어야 한다. 
- 또한 `PC`에 들어갈 값으로 순차적인 다음 명령어 주소(PC + 4)와 분기 목적지 주소 중 하나를 선택하기 위해 또 다른 `멀티 플렉서`가 필요하다.  <br />

<img width="552" alt="그림4-11" src="https://user-images.githubusercontent.com/40673012/100285833-ebb41b00-2fb4-11eb-8b76-143961e19b86.png">

# 4.4 단순한 구현
- 목표: RISC-V 부분집합을 간단히 구현하면 어떤 형태가 될지 알아본다. 4.3절의 데이터패스에 단순한 제어 기능을 추가하여 단순한 구현을 만든다.
    - 단순한 구현에 ld(load doubleword), sd(store doubleword), beq(branch if equal)과 R-타입 명령어인 add,sub,and,or 명령어를 포함한다.
    
## ALU 제어
- RISC-V ALU는 `제어 입력 4개`를 사용하는 다음 4개 조합을 정의한다.<br />
ALU는 명령어 종류에 따라 이 네 가지 기능 중 하나를 수행한다.

|ALU 제어선|기능|
|--|--|
|0000|AND|
|0001|OR|
|0010|add|
|0110|subtract|

- `ld, sd 명령어`인 경우에는 메모리 주소를 계산하기 위한 덧셈용으로 ALU를 사용한다.
- `R-형식`명령어의 경우명령어 7비트 `funct7` 필드(비트 31:25)와 3비트 `func3`필드(비트14:12) 값에 따라 <br />
4가지 연산(AND, OR, add subtract) 중 하나를 수행한다.
- 조건부 분기 명령어 `beq`의 경우 ALU는 두 피연산자의 경우 ALU는 두 피연산자의 뺄셈을 한 후 결과가 0인지 아닌지 테스트한다. <br />

- 명령어의 `func7`필드와  `func3`필드 그리고 `ALUOp`라 불리는 2비트 제어 필드를 입력으로 하는 조그만 제어 유닛을 만들어서 4비트 `ALU 제어신호`를 발생시킬 수 있다.
- `ALUOp`는 ALU가 수행해야 할 연산을 표시한다. `적재나 저장` 명령어의 경우 덧셈(00), `beq`의 경우 뺄셈과 결과치가 0인지 테스트하기(01), 아니면 `func7과 func3` 필드가 나타내는 연산(10)이 된다.
- ALU 제어 유닛의 출력은 4비트 신호인데 이 4비트 신호는 앞서 말한 4비트 조합 중 하나를 만들어 ALU를 직접 제어한다.
- `그림 4.12`는 2비트 ALUOp 제어와 funct7 필드, funct3 필드를 사용하여 어떻게 ALU 제어 입력을 만드는지 보여준다.

![그림4.12](https://user-images.githubusercontent.com/40673012/100301824-5d538f80-2fdc-11eb-8e38-3d3a5f0b5d8a.png)

- `주 제어 유닛`이 `ALUOp 비트`를 생성하고 `ALU 제어 유닛`은 이것을 입력으로 받아  <br />
`ALU를 제어하는 실제 신호`를 만들어 내는 다단계 디코딩은 많이 쓰이는 구현기법이다. <br />
`다단계 제어`를 사용하면 주 제어 유닛의 크기를 줄일 수 있고,  여러 개의 작은 제어 유닛을 사용하면 <br />
제어 유닛의 속도를 증가시킬 수 있다.
    - 제어 유닛의 속도가 클럭 사이클 시간에 영향을 미치는 경우가 많아 이러한 최적화는 중요하다. <br />
     
- 2비트 ALUOp 필드와 funct 필드를 4비트의 ALU 연산 제어 비트로 사상시키는 방법: <br />
ALUOp, funct 필드의 값들 중 일부를 인식하고 적당항 ALU 제어신호를 만들어 내는 논리회로 설계.

- 위 논리회로를 설계하는 단계로서 funct 필드와 ALUOp 비트의 관심 있는 조합에 대한 `진리표`를 만드는 것은 도움이 된다. 그림 4.14가 이 진리표이다. <br />
이 `진리표`(truth table)는 입력 필드 값에 따라 4비트 ALU 제어값이 어떻게 설정되는지 보여 준다.

![그림4.13](https://user-images.githubusercontent.com/40673012/100301829-5fb5e980-2fdc-11eb-8a1b-fb324cd6a931.png)

## 주 제어 유닛의 설계
- `opcode` 필드는 항상 비트 6:0의 7비트에 있는데(2장 참조) opcode에 따라서 funct3 필드(비트14:12)와 funct7 필드(비트31:25)가 확장 opcode 필드로 사용된다.
- `R-형식` 명령어와 `분기명령어`의 경우에는 `첫 번째 레지스터 피연산자`가 비트19:15(rs1)에 있는데, `적재/저장 명령어`에는 이 필드가 `베이스 레지스터`로 사용된다.
- R-형식 명령어와 분기명령어의 경우 `두 번째 레지스터 피연산자`가 비트 24:20(rs2)에 있다. 저장 명령어의 경우에는 이 필드가 `메모리에 저장될 레지스터 피연산자`를 나타낸다.
- 분기 명령이나 적재/저장 명령어의 다른 피연산자 하나는 12비트 변위이다.
- R-형식 명령어와 적재 명령어의 목적지 레지스터는 항상 비트 11:7(rd)에 있다.


![그림4.14](https://user-images.githubusercontent.com/40673012/100301831-604e8000-2fdc-11eb-93e0-2ae1ec93ff97.png)

- 그림 4.15는 ALU 제어 블록, 상태소자용 쓰기 신호, 데이터 메모리용 읽기 신호, 멀티플렉서용 제어 신호를 보여 준다. <br />
여기에는 1비트 제어선 6개와 2비트 ALUOp 제어신호 하나가 있다. ALUOp 제어신호의 동작은 앞서 설명하였다. <br />
그림 4.16은 나머지 6개의 제어신호들이 무슨 일을 하는지 정의한다.

![그림4.15](https://user-images.githubusercontent.com/40673012/100301832-617fad00-2fdc-11eb-848b-51bfac11eaf8.png)

![그림4.16](https://user-images.githubusercontent.com/40673012/100301834-617fad00-2fdc-11eb-9819-d328a01b9677.png)

### 제어선의 값
- 제어 유닛은 제어신호 중 `PCSrc 제어선`을 제외한 나머지 모두를 명령어의 opcode필드와 funct 필드만 보고 결정할 수 있다. <br />
- 실행 중인 명령어가 `beq`이며(제어 유닛이 판단 가능) 동시에 `ALU의 Zero 출력`(같은지 테스트할 때 사용)이 참일 경우에만 PCSrc가 인가된다.  RCSrc 신호를 만드려면 제어 유닛에서 나오는 Branch 신호와 ALU Zero 신호를 AND해야 한다.
- 8개의 `제어신호`(그림 4.16의 6개 + AlUOp 두 비트)들은 제어 유닛의 `입력 신호`(opcode 비트 6:0)에 따라서 결정된다. 그림 4.17은 제어 유닛과 제어신호가 나와 있는 데이터패스 그림이다.

![그림4.17](https://user-images.githubusercontent.com/40673012/100301842-647a9d80-2fdc-11eb-93ef-222170fbdf83.png)


- 그림 4.18은 제어신호들이 각각의 opcode에 대해 어떤 값이 되어야 하는지 나타낸다.

## 데이터패스의 동작
- 그림 4.16과 4.18에 포함된 정보를 가지고 제어 유닛의 논리회로를 설계할 수 있다.

![그림4.18](https://user-images.githubusercontent.com/40673012/100301844-65133400-2fdc-11eb-99da-d4442c37e589.png)

- 그림 4.19는 add x1, x2, x3와 같은 R-형식 명령어의 데이터패스 동작을 보여준다.
    - 1. 명령어를 명령어 메모리에서 가져오고 PC값을 증가시킨다. <br />
    - 2. 두 레지스터 x2와 x3를 레지스터 파일로부터 읽는다. 이 단계에서 주 제어 유닛이 제어선의 값을 계산한다. <br />
    - 3. ALU 레지스터 파일에서 읽어 들인 값들에 대해 연산을 하는데 opcode 부분을 사용하여 ALU 제어신호를 만든다.<br />
    - 4. ALU의 결과값이 레지스터 파일의 목적지 레지스터(x1)에 써진다.<br />

![그림4.19](https://user-images.githubusercontent.com/40673012/100301837-62b0da00-2fdc-11eb-97cf-e8f05c023811.png)

- 그림 4.20은 적재 명령어를 위하여 활성화된 기능 유닛과 인가된 제어선들을 보여준다. <br />
ld x1, offset(x2)와 같은 적재 명령어는 5단계 동작으로 생각할 수 있다. (R-형식 명령어는 4단계)
    - 1. 명령어를 명령어 메모리에서 가져오고 PC값을 증가시킨다.<br />
    - 2. 레지스터(x2)값을 레지스터 파일로부터 읽는다. <br />
    - 3. ALU는 레지스터 파일에서 읽어 들인 값과 명령어의 12비트(offset)를 부호확장한 값의 합을 구한다. <br />
    - 4. 이 합을 데이터 메모리 접근을 위한 주소로 사용한다.<br />
    - 5. 메모리 유닛에서 가져온 데이터를 레지스터 파일(x1)에 기록한다.<br />

![그림4.20](https://user-images.githubusercontent.com/40673012/100301840-63497080-2fdc-11eb-8361-1b08a13a9f1d.png)

-  마지막으로 그림 4.21은 beq x1, x2, offset와 같은 조건부 분기 명령어의 데이터패스 동작을 네 단계로 보여준다.
    - 1. 명령어를 명령어 메모리에서 가져오고 PC값을 증가시킨다. <br />
    - 2. 두 개의 레지스터 x1과 x3를 레지스터 파일로부터 읽는다. <br />
    - 3. ALU는 레지스터 파일에서 읽어 들인 두 개의 값을 사용하여 하나의 값에서 다른 값을 뺀다.<br />
    명령어의 12비트(offset)를 부호확장한 후 1비트 왼쪽 자리이동한 값에다 PC값을 더한다. 결과값이 분기 목적지 주소이다.
    - 4. 어떤 덧셈기의 결과를 PC에 저장할지 ALU의 Zero 출력을 이용하여 판단한다.<br />
    
- 이 명령어는 R-형식 명령어와 비슷하게 동작한다. <br />
그러나 ALU 출력이 PC값을 PC +4로 바꿀 것인가 아니면 분기 목적지 주소로 바꿀 것인가를 결정하는 데 사용된다는 점이 다른다.

![그림4.21](https://user-images.githubusercontent.com/40673012/100301839-63497080-2fdc-11eb-8b56-bd8da38fdfd3.png)

## 제어 유닛의 완성
- 제어 유닛의 출력은 제어선들이며 입력은 opcode 필드이다. 따라서 opcode의 이진수 인코딩을 이용하여 각 출력의 진리표를 만들 수 있다.
- 그림 4.22는 제어 유닛의 논리를 진리표 하나로 만든 것이다. 이 표는 모든 출력을 망라하며 opcode 비트들을 입력으로 사용한다. <br />
이것은 제어 기능을 완벽하게 명시하며 자동화된 방법을 이용하여 게이트로 곧바로 구현할 수 있다.

<img width="476" alt=그림4-22" src="https://user-images.githubusercontent.com/40673012/100397548-93048100-308d-11eb-9053-38211887122a.png">


## 단일 사이클 구현은 오늘날 왜 사용되지 않는가?
- 비효율성 때문이다.
- 단일 사이클 설계에서 클럭 사이클은 모든 명령어에 대해 같은 길이를 갖는다. <br />
이 길이는 클럭 사이클은 컴퓨터에서 가능한 경로 중 가장 긴 경로에 의해 결정된다. <br />
최장 경로를 적재 명령어로 명령어 메모리, 레지스터 파일, ALU, 데이터 메모리, 레지스터 파일의 다섯 개 기능 유닛을 차례로 사용한다. <br />
단일 사이클 구현의 CPI값은 1이지만 클럭 사이클이 너무 길기 때문에 전체 성능은 좋지 않다.

